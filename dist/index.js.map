{"version":3,"file":"index.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9sDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjKA;AAtGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;ACzJA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;;;;;ACDA;;AAEA;AACA;AAEA","sources":[".././node_modules/@actions/core/lib/command.js",".././node_modules/@actions/core/lib/core.js",".././node_modules/@actions/core/lib/file-command.js",".././node_modules/@actions/core/lib/oidc-utils.js",".././node_modules/@actions/core/lib/path-utils.js",".././node_modules/@actions/core/lib/platform.js",".././node_modules/@actions/core/lib/summary.js",".././node_modules/@actions/core/lib/utils.js",".././node_modules/@actions/exec/lib/exec.js",".././node_modules/@actions/exec/lib/toolrunner.js",".././node_modules/@actions/http-client/lib/auth.js",".././node_modules/@actions/http-client/lib/index.js",".././node_modules/@actions/http-client/lib/proxy.js",".././node_modules/@actions/io/lib/io-util.js",".././node_modules/@actions/io/lib/io.js",".././node_modules/libarchive-wasm/dist/ArchiveReader.js",".././node_modules/libarchive-wasm/dist/ArchiveReaderEntry.js",".././node_modules/libarchive-wasm/dist/index.js",".././node_modules/libarchive-wasm/dist/libarchive.js",".././node_modules/libarchive-wasm/dist/libarchiveWasm.js",".././node_modules/libarchive-wasm/dist/wrapLibarchiveWasm.js",".././node_modules/tunnel/index.js",".././node_modules/tunnel/lib/tunnel.js",".././src/main.ts","../external node-commonjs \"assert\"","../external node-commonjs \"child_process\"","../external node-commonjs \"crypto\"","../external node-commonjs \"events\"","../external node-commonjs \"fs\"","../external node-commonjs \"http\"","../external node-commonjs \"https\"","../external node-commonjs \"net\"","../external node-commonjs \"node:fs/promises\"","../external node-commonjs \"os\"","../external node-commonjs \"path\"","../external node-commonjs \"stream\"","../external node-commonjs \"stream/promises\"","../external node-commonjs \"string_decoder\"","../external node-commonjs \"timers\"","../external node-commonjs \"tls\"","../external node-commonjs \"util\"","../webpack/bootstrap","../webpack/runtime/compat",".././src/index.ts"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return (0, utils_1.toCommandValue)(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return (0, utils_1.toCommandValue)(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst oidc_utils_1 = require(\"./oidc-utils\");\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode || (exports.ExitCode = ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = (0, utils_1.toCommandValue)(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        return (0, file_command_1.issueFileCommand)('ENV', (0, file_command_1.prepareKeyValueMessage)(name, val));\n    }\n    (0, command_1.issueCommand)('set-env', { name }, convertedVal);\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    (0, command_1.issueCommand)('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        (0, file_command_1.issueFileCommand)('PATH', inputPath);\n    }\n    else {\n        (0, command_1.issueCommand)('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    if (options && options.trimWhitespace === false) {\n        return inputs;\n    }\n    return inputs.map(input => input.trim());\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    const filePath = process.env['GITHUB_OUTPUT'] || '';\n    if (filePath) {\n        return (0, file_command_1.issueFileCommand)('OUTPUT', (0, file_command_1.prepareKeyValueMessage)(name, value));\n    }\n    process.stdout.write(os.EOL);\n    (0, command_1.issueCommand)('set-output', { name }, (0, utils_1.toCommandValue)(value));\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    (0, command_1.issue)('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    (0, command_1.issueCommand)('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction error(message, properties = {}) {\n    (0, command_1.issueCommand)('error', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction warning(message, properties = {}) {\n    (0, command_1.issueCommand)('warning', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction notice(message, properties = {}) {\n    (0, command_1.issueCommand)('notice', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    (0, command_1.issue)('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    (0, command_1.issue)('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    const filePath = process.env['GITHUB_STATE'] || '';\n    if (filePath) {\n        return (0, file_command_1.issueFileCommand)('STATE', (0, file_command_1.prepareKeyValueMessage)(name, value));\n    }\n    (0, command_1.issueCommand)('save-state', { name }, (0, utils_1.toCommandValue)(value));\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\nfunction getIDToken(aud) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield oidc_utils_1.OidcClient.getIDToken(aud);\n    });\n}\nexports.getIDToken = getIDToken;\n/**\n * Summary exports\n */\nvar summary_1 = require(\"./summary\");\nObject.defineProperty(exports, \"summary\", { enumerable: true, get: function () { return summary_1.summary; } });\n/**\n * @deprecated use core.summary\n */\nvar summary_2 = require(\"./summary\");\nObject.defineProperty(exports, \"markdownSummary\", { enumerable: true, get: function () { return summary_2.markdownSummary; } });\n/**\n * Path exports\n */\nvar path_utils_1 = require(\"./path-utils\");\nObject.defineProperty(exports, \"toPosixPath\", { enumerable: true, get: function () { return path_utils_1.toPosixPath; } });\nObject.defineProperty(exports, \"toWin32Path\", { enumerable: true, get: function () { return path_utils_1.toWin32Path; } });\nObject.defineProperty(exports, \"toPlatformPath\", { enumerable: true, get: function () { return path_utils_1.toPlatformPath; } });\n/**\n * Platform utilities exports\n */\nexports.platform = __importStar(require(\"./platform\"));\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.prepareKeyValueMessage = exports.issueFileCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst crypto = __importStar(require(\"crypto\"));\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\nfunction issueFileCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueFileCommand = issueFileCommand;\nfunction prepareKeyValueMessage(key, value) {\n    const delimiter = `ghadelimiter_${crypto.randomUUID()}`;\n    const convertedValue = (0, utils_1.toCommandValue)(value);\n    // These should realistically never happen, but just in case someone finds a\n    // way to exploit uuid generation let's not allow keys or values that contain\n    // the delimiter.\n    if (key.includes(delimiter)) {\n        throw new Error(`Unexpected input: name should not contain the delimiter \"${delimiter}\"`);\n    }\n    if (convertedValue.includes(delimiter)) {\n        throw new Error(`Unexpected input: value should not contain the delimiter \"${delimiter}\"`);\n    }\n    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;\n}\nexports.prepareKeyValueMessage = prepareKeyValueMessage;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OidcClient = void 0;\nconst http_client_1 = require(\"@actions/http-client\");\nconst auth_1 = require(\"@actions/http-client/lib/auth\");\nconst core_1 = require(\"./core\");\nclass OidcClient {\n    static createHttpClient(allowRetry = true, maxRetry = 10) {\n        const requestOptions = {\n            allowRetries: allowRetry,\n            maxRetries: maxRetry\n        };\n        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);\n    }\n    static getRequestToken() {\n        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];\n        if (!token) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');\n        }\n        return token;\n    }\n    static getIDTokenUrl() {\n        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];\n        if (!runtimeUrl) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');\n        }\n        return runtimeUrl;\n    }\n    static getCall(id_token_url) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const httpclient = OidcClient.createHttpClient();\n            const res = yield httpclient\n                .getJson(id_token_url)\n                .catch(error => {\n                throw new Error(`Failed to get ID Token. \\n \n        Error Code : ${error.statusCode}\\n \n        Error Message: ${error.message}`);\n            });\n            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;\n            if (!id_token) {\n                throw new Error('Response json body do not have ID Token field');\n            }\n            return id_token;\n        });\n    }\n    static getIDToken(audience) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // New ID Token is requested from action service\n                let id_token_url = OidcClient.getIDTokenUrl();\n                if (audience) {\n                    const encodedAudience = encodeURIComponent(audience);\n                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;\n                }\n                (0, core_1.debug)(`ID token url is ${id_token_url}`);\n                const id_token = yield OidcClient.getCall(id_token_url);\n                (0, core_1.setSecret)(id_token);\n                return id_token;\n            }\n            catch (error) {\n                throw new Error(`Error message: ${error.message}`);\n            }\n        });\n    }\n}\nexports.OidcClient = OidcClient;\n//# sourceMappingURL=oidc-utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;\nconst path = __importStar(require(\"path\"));\n/**\n * toPosixPath converts the given path to the posix form. On Windows, \\\\ will be\n * replaced with /.\n *\n * @param pth. Path to transform.\n * @return string Posix path.\n */\nfunction toPosixPath(pth) {\n    return pth.replace(/[\\\\]/g, '/');\n}\nexports.toPosixPath = toPosixPath;\n/**\n * toWin32Path converts the given path to the win32 form. On Linux, / will be\n * replaced with \\\\.\n *\n * @param pth. Path to transform.\n * @return string Win32 path.\n */\nfunction toWin32Path(pth) {\n    return pth.replace(/[/]/g, '\\\\');\n}\nexports.toWin32Path = toWin32Path;\n/**\n * toPlatformPath converts the given path to a platform-specific path. It does\n * this by replacing instances of / and \\ with the platform-specific path\n * separator.\n *\n * @param pth The path to platformize.\n * @return string The platform-specific path.\n */\nfunction toPlatformPath(pth) {\n    return pth.replace(/[/\\\\]/g, path.sep);\n}\nexports.toPlatformPath = toPlatformPath;\n//# sourceMappingURL=path-utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getDetails = exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = void 0;\nconst os_1 = __importDefault(require(\"os\"));\nconst exec = __importStar(require(\"@actions/exec\"));\nconst getWindowsInfo = () => __awaiter(void 0, void 0, void 0, function* () {\n    const { stdout: version } = yield exec.getExecOutput('powershell -command \"(Get-CimInstance -ClassName Win32_OperatingSystem).Version\"', undefined, {\n        silent: true\n    });\n    const { stdout: name } = yield exec.getExecOutput('powershell -command \"(Get-CimInstance -ClassName Win32_OperatingSystem).Caption\"', undefined, {\n        silent: true\n    });\n    return {\n        name: name.trim(),\n        version: version.trim()\n    };\n});\nconst getMacOsInfo = () => __awaiter(void 0, void 0, void 0, function* () {\n    var _a, _b, _c, _d;\n    const { stdout } = yield exec.getExecOutput('sw_vers', undefined, {\n        silent: true\n    });\n    const version = (_b = (_a = stdout.match(/ProductVersion:\\s*(.+)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : '';\n    const name = (_d = (_c = stdout.match(/ProductName:\\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : '';\n    return {\n        name,\n        version\n    };\n});\nconst getLinuxInfo = () => __awaiter(void 0, void 0, void 0, function* () {\n    const { stdout } = yield exec.getExecOutput('lsb_release', ['-i', '-r', '-s'], {\n        silent: true\n    });\n    const [name, version] = stdout.trim().split('\\n');\n    return {\n        name,\n        version\n    };\n});\nexports.platform = os_1.default.platform();\nexports.arch = os_1.default.arch();\nexports.isWindows = exports.platform === 'win32';\nexports.isMacOS = exports.platform === 'darwin';\nexports.isLinux = exports.platform === 'linux';\nfunction getDetails() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return Object.assign(Object.assign({}, (yield (exports.isWindows\n            ? getWindowsInfo()\n            : exports.isMacOS\n                ? getMacOsInfo()\n                : getLinuxInfo()))), { platform: exports.platform,\n            arch: exports.arch,\n            isWindows: exports.isWindows,\n            isMacOS: exports.isMacOS,\n            isLinux: exports.isLinux });\n    });\n}\nexports.getDetails = getDetails;\n//# sourceMappingURL=platform.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;\nconst os_1 = require(\"os\");\nconst fs_1 = require(\"fs\");\nconst { access, appendFile, writeFile } = fs_1.promises;\nexports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';\nexports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';\nclass Summary {\n    constructor() {\n        this._buffer = '';\n    }\n    /**\n     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist\n     * Also checks r/w permissions.\n     *\n     * @returns step summary file path\n     */\n    filePath() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._filePath) {\n                return this._filePath;\n            }\n            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];\n            if (!pathFromEnv) {\n                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);\n            }\n            try {\n                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);\n            }\n            catch (_a) {\n                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);\n            }\n            this._filePath = pathFromEnv;\n            return this._filePath;\n        });\n    }\n    /**\n     * Wraps content in an HTML tag, adding any HTML attributes\n     *\n     * @param {string} tag HTML tag to wrap\n     * @param {string | null} content content within the tag\n     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add\n     *\n     * @returns {string} content wrapped in HTML element\n     */\n    wrap(tag, content, attrs = {}) {\n        const htmlAttrs = Object.entries(attrs)\n            .map(([key, value]) => ` ${key}=\"${value}\"`)\n            .join('');\n        if (!content) {\n            return `<${tag}${htmlAttrs}>`;\n        }\n        return `<${tag}${htmlAttrs}>${content}</${tag}>`;\n    }\n    /**\n     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.\n     *\n     * @param {SummaryWriteOptions} [options] (optional) options for write operation\n     *\n     * @returns {Promise<Summary>} summary instance\n     */\n    write(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);\n            const filePath = yield this.filePath();\n            const writeFunc = overwrite ? writeFile : appendFile;\n            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });\n            return this.emptyBuffer();\n        });\n    }\n    /**\n     * Clears the summary buffer and wipes the summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.emptyBuffer().write({ overwrite: true });\n        });\n    }\n    /**\n     * Returns the current summary buffer as a string\n     *\n     * @returns {string} string of summary buffer\n     */\n    stringify() {\n        return this._buffer;\n    }\n    /**\n     * If the summary buffer is empty\n     *\n     * @returns {boolen} true if the buffer is empty\n     */\n    isEmptyBuffer() {\n        return this._buffer.length === 0;\n    }\n    /**\n     * Resets the summary buffer without writing to summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    emptyBuffer() {\n        this._buffer = '';\n        return this;\n    }\n    /**\n     * Adds raw text to the summary buffer\n     *\n     * @param {string} text content to add\n     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addRaw(text, addEOL = false) {\n        this._buffer += text;\n        return addEOL ? this.addEOL() : this;\n    }\n    /**\n     * Adds the operating system-specific end-of-line marker to the buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addEOL() {\n        return this.addRaw(os_1.EOL);\n    }\n    /**\n     * Adds an HTML codeblock to the summary buffer\n     *\n     * @param {string} code content to render within fenced code block\n     * @param {string} lang (optional) language to syntax highlight code\n     *\n     * @returns {Summary} summary instance\n     */\n    addCodeBlock(code, lang) {\n        const attrs = Object.assign({}, (lang && { lang }));\n        const element = this.wrap('pre', this.wrap('code', code), attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML list to the summary buffer\n     *\n     * @param {string[]} items list of items to render\n     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addList(items, ordered = false) {\n        const tag = ordered ? 'ol' : 'ul';\n        const listItems = items.map(item => this.wrap('li', item)).join('');\n        const element = this.wrap(tag, listItems);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML table to the summary buffer\n     *\n     * @param {SummaryTableCell[]} rows table rows\n     *\n     * @returns {Summary} summary instance\n     */\n    addTable(rows) {\n        const tableBody = rows\n            .map(row => {\n            const cells = row\n                .map(cell => {\n                if (typeof cell === 'string') {\n                    return this.wrap('td', cell);\n                }\n                const { header, data, colspan, rowspan } = cell;\n                const tag = header ? 'th' : 'td';\n                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));\n                return this.wrap(tag, data, attrs);\n            })\n                .join('');\n            return this.wrap('tr', cells);\n        })\n            .join('');\n        const element = this.wrap('table', tableBody);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds a collapsable HTML details element to the summary buffer\n     *\n     * @param {string} label text for the closed state\n     * @param {string} content collapsable content\n     *\n     * @returns {Summary} summary instance\n     */\n    addDetails(label, content) {\n        const element = this.wrap('details', this.wrap('summary', label) + content);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML image tag to the summary buffer\n     *\n     * @param {string} src path to the image you to embed\n     * @param {string} alt text description of the image\n     * @param {SummaryImageOptions} options (optional) addition image attributes\n     *\n     * @returns {Summary} summary instance\n     */\n    addImage(src, alt, options) {\n        const { width, height } = options || {};\n        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));\n        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML section heading element\n     *\n     * @param {string} text heading text\n     * @param {number | string} [level=1] (optional) the heading level, default: 1\n     *\n     * @returns {Summary} summary instance\n     */\n    addHeading(text, level) {\n        const tag = `h${level}`;\n        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)\n            ? tag\n            : 'h1';\n        const element = this.wrap(allowedTag, text);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML thematic break (<hr>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addSeparator() {\n        const element = this.wrap('hr', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML line break (<br>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addBreak() {\n        const element = this.wrap('br', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML blockquote to the summary buffer\n     *\n     * @param {string} text quote text\n     * @param {string} cite (optional) citation url\n     *\n     * @returns {Summary} summary instance\n     */\n    addQuote(text, cite) {\n        const attrs = Object.assign({}, (cite && { cite }));\n        const element = this.wrap('blockquote', text, attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML anchor tag to the summary buffer\n     *\n     * @param {string} text link text/content\n     * @param {string} href hyperlink\n     *\n     * @returns {Summary} summary instance\n     */\n    addLink(text, href) {\n        const element = this.wrap('a', text, { href });\n        return this.addRaw(element).addEOL();\n    }\n}\nconst _summary = new Summary();\n/**\n * @deprecated use `core.summary`\n */\nexports.markdownSummary = _summary;\nexports.summary = _summary;\n//# sourceMappingURL=summary.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */\nfunction toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) {\n        return {};\n    }\n    return {\n        title: annotationProperties.title,\n        file: annotationProperties.file,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getExecOutput = exports.exec = void 0;\nconst string_decoder_1 = require(\"string_decoder\");\nconst tr = __importStar(require(\"./toolrunner\"));\n/**\n * Exec a command.\n * Output will be streamed to the live console.\n * Returns promise with return code\n *\n * @param     commandLine        command to execute (can include additional args). Must be correctly escaped.\n * @param     args               optional arguments for tool. Escaping is handled by the lib.\n * @param     options            optional exec options.  See ExecOptions\n * @returns   Promise<number>    exit code\n */\nfunction exec(commandLine, args, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const commandArgs = tr.argStringToArray(commandLine);\n        if (commandArgs.length === 0) {\n            throw new Error(`Parameter 'commandLine' cannot be null or empty.`);\n        }\n        // Path to tool to execute should be first arg\n        const toolPath = commandArgs[0];\n        args = commandArgs.slice(1).concat(args || []);\n        const runner = new tr.ToolRunner(toolPath, args, options);\n        return runner.exec();\n    });\n}\nexports.exec = exec;\n/**\n * Exec a command and get the output.\n * Output will be streamed to the live console.\n * Returns promise with the exit code and collected stdout and stderr\n *\n * @param     commandLine           command to execute (can include additional args). Must be correctly escaped.\n * @param     args                  optional arguments for tool. Escaping is handled by the lib.\n * @param     options               optional exec options.  See ExecOptions\n * @returns   Promise<ExecOutput>   exit code, stdout, and stderr\n */\nfunction getExecOutput(commandLine, args, options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n        let stdout = '';\n        let stderr = '';\n        //Using string decoder covers the case where a mult-byte character is split\n        const stdoutDecoder = new string_decoder_1.StringDecoder('utf8');\n        const stderrDecoder = new string_decoder_1.StringDecoder('utf8');\n        const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;\n        const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;\n        const stdErrListener = (data) => {\n            stderr += stderrDecoder.write(data);\n            if (originalStdErrListener) {\n                originalStdErrListener(data);\n            }\n        };\n        const stdOutListener = (data) => {\n            stdout += stdoutDecoder.write(data);\n            if (originalStdoutListener) {\n                originalStdoutListener(data);\n            }\n        };\n        const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });\n        const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));\n        //flush any remaining characters\n        stdout += stdoutDecoder.end();\n        stderr += stderrDecoder.end();\n        return {\n            exitCode,\n            stdout,\n            stderr\n        };\n    });\n}\nexports.getExecOutput = getExecOutput;\n//# sourceMappingURL=exec.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.argStringToArray = exports.ToolRunner = void 0;\nconst os = __importStar(require(\"os\"));\nconst events = __importStar(require(\"events\"));\nconst child = __importStar(require(\"child_process\"));\nconst path = __importStar(require(\"path\"));\nconst io = __importStar(require(\"@actions/io\"));\nconst ioUtil = __importStar(require(\"@actions/io/lib/io-util\"));\nconst timers_1 = require(\"timers\");\n/* eslint-disable @typescript-eslint/unbound-method */\nconst IS_WINDOWS = process.platform === 'win32';\n/*\n * Class for running command line tools. Handles quoting and arg parsing in a platform agnostic way.\n */\nclass ToolRunner extends events.EventEmitter {\n    constructor(toolPath, args, options) {\n        super();\n        if (!toolPath) {\n            throw new Error(\"Parameter 'toolPath' cannot be null or empty.\");\n        }\n        this.toolPath = toolPath;\n        this.args = args || [];\n        this.options = options || {};\n    }\n    _debug(message) {\n        if (this.options.listeners && this.options.listeners.debug) {\n            this.options.listeners.debug(message);\n        }\n    }\n    _getCommandString(options, noPrefix) {\n        const toolPath = this._getSpawnFileName();\n        const args = this._getSpawnArgs(options);\n        let cmd = noPrefix ? '' : '[command]'; // omit prefix when piped to a second tool\n        if (IS_WINDOWS) {\n            // Windows + cmd file\n            if (this._isCmdFile()) {\n                cmd += toolPath;\n                for (const a of args) {\n                    cmd += ` ${a}`;\n                }\n            }\n            // Windows + verbatim\n            else if (options.windowsVerbatimArguments) {\n                cmd += `\"${toolPath}\"`;\n                for (const a of args) {\n                    cmd += ` ${a}`;\n                }\n            }\n            // Windows (regular)\n            else {\n                cmd += this._windowsQuoteCmdArg(toolPath);\n                for (const a of args) {\n                    cmd += ` ${this._windowsQuoteCmdArg(a)}`;\n                }\n            }\n        }\n        else {\n            // OSX/Linux - this can likely be improved with some form of quoting.\n            // creating processes on Unix is fundamentally different than Windows.\n            // on Unix, execvp() takes an arg array.\n            cmd += toolPath;\n            for (const a of args) {\n                cmd += ` ${a}`;\n            }\n        }\n        return cmd;\n    }\n    _processLineBuffer(data, strBuffer, onLine) {\n        try {\n            let s = strBuffer + data.toString();\n            let n = s.indexOf(os.EOL);\n            while (n > -1) {\n                const line = s.substring(0, n);\n                onLine(line);\n                // the rest of the string ...\n                s = s.substring(n + os.EOL.length);\n                n = s.indexOf(os.EOL);\n            }\n            return s;\n        }\n        catch (err) {\n            // streaming lines to console is best effort.  Don't fail a build.\n            this._debug(`error processing line. Failed with error ${err}`);\n            return '';\n        }\n    }\n    _getSpawnFileName() {\n        if (IS_WINDOWS) {\n            if (this._isCmdFile()) {\n                return process.env['COMSPEC'] || 'cmd.exe';\n            }\n        }\n        return this.toolPath;\n    }\n    _getSpawnArgs(options) {\n        if (IS_WINDOWS) {\n            if (this._isCmdFile()) {\n                let argline = `/D /S /C \"${this._windowsQuoteCmdArg(this.toolPath)}`;\n                for (const a of this.args) {\n                    argline += ' ';\n                    argline += options.windowsVerbatimArguments\n                        ? a\n                        : this._windowsQuoteCmdArg(a);\n                }\n                argline += '\"';\n                return [argline];\n            }\n        }\n        return this.args;\n    }\n    _endsWith(str, end) {\n        return str.endsWith(end);\n    }\n    _isCmdFile() {\n        const upperToolPath = this.toolPath.toUpperCase();\n        return (this._endsWith(upperToolPath, '.CMD') ||\n            this._endsWith(upperToolPath, '.BAT'));\n    }\n    _windowsQuoteCmdArg(arg) {\n        // for .exe, apply the normal quoting rules that libuv applies\n        if (!this._isCmdFile()) {\n            return this._uvQuoteCmdArg(arg);\n        }\n        // otherwise apply quoting rules specific to the cmd.exe command line parser.\n        // the libuv rules are generic and are not designed specifically for cmd.exe\n        // command line parser.\n        //\n        // for a detailed description of the cmd.exe command line parser, refer to\n        // http://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts/7970912#7970912\n        // need quotes for empty arg\n        if (!arg) {\n            return '\"\"';\n        }\n        // determine whether the arg needs to be quoted\n        const cmdSpecialChars = [\n            ' ',\n            '\\t',\n            '&',\n            '(',\n            ')',\n            '[',\n            ']',\n            '{',\n            '}',\n            '^',\n            '=',\n            ';',\n            '!',\n            \"'\",\n            '+',\n            ',',\n            '`',\n            '~',\n            '|',\n            '<',\n            '>',\n            '\"'\n        ];\n        let needsQuotes = false;\n        for (const char of arg) {\n            if (cmdSpecialChars.some(x => x === char)) {\n                needsQuotes = true;\n                break;\n            }\n        }\n        // short-circuit if quotes not needed\n        if (!needsQuotes) {\n            return arg;\n        }\n        // the following quoting rules are very similar to the rules that by libuv applies.\n        //\n        // 1) wrap the string in quotes\n        //\n        // 2) double-up quotes - i.e. \" => \"\"\n        //\n        //    this is different from the libuv quoting rules. libuv replaces \" with \\\", which unfortunately\n        //    doesn't work well with a cmd.exe command line.\n        //\n        //    note, replacing \" with \"\" also works well if the arg is passed to a downstream .NET console app.\n        //    for example, the command line:\n        //          foo.exe \"myarg:\"\"my val\"\"\"\n        //    is parsed by a .NET console app into an arg array:\n        //          [ \"myarg:\\\"my val\\\"\" ]\n        //    which is the same end result when applying libuv quoting rules. although the actual\n        //    command line from libuv quoting rules would look like:\n        //          foo.exe \"myarg:\\\"my val\\\"\"\n        //\n        // 3) double-up slashes that precede a quote,\n        //    e.g.  hello \\world    => \"hello \\world\"\n        //          hello\\\"world    => \"hello\\\\\"\"world\"\n        //          hello\\\\\"world   => \"hello\\\\\\\\\"\"world\"\n        //          hello world\\    => \"hello world\\\\\"\n        //\n        //    technically this is not required for a cmd.exe command line, or the batch argument parser.\n        //    the reasons for including this as a .cmd quoting rule are:\n        //\n        //    a) this is optimized for the scenario where the argument is passed from the .cmd file to an\n        //       external program. many programs (e.g. .NET console apps) rely on the slash-doubling rule.\n        //\n        //    b) it's what we've been doing previously (by deferring to node default behavior) and we\n        //       haven't heard any complaints about that aspect.\n        //\n        // note, a weakness of the quoting rules chosen here, is that % is not escaped. in fact, % cannot be\n        // escaped when used on the command line directly - even though within a .cmd file % can be escaped\n        // by using %%.\n        //\n        // the saving grace is, on the command line, %var% is left as-is if var is not defined. this contrasts\n        // the line parsing rules within a .cmd file, where if var is not defined it is replaced with nothing.\n        //\n        // one option that was explored was replacing % with ^% - i.e. %var% => ^%var^%. this hack would\n        // often work, since it is unlikely that var^ would exist, and the ^ character is removed when the\n        // variable is used. the problem, however, is that ^ is not removed when %* is used to pass the args\n        // to an external program.\n        //\n        // an unexplored potential solution for the % escaping problem, is to create a wrapper .cmd file.\n        // % can be escaped within a .cmd file.\n        let reverse = '\"';\n        let quoteHit = true;\n        for (let i = arg.length; i > 0; i--) {\n            // walk the string in reverse\n            reverse += arg[i - 1];\n            if (quoteHit && arg[i - 1] === '\\\\') {\n                reverse += '\\\\'; // double the slash\n            }\n            else if (arg[i - 1] === '\"') {\n                quoteHit = true;\n                reverse += '\"'; // double the quote\n            }\n            else {\n                quoteHit = false;\n            }\n        }\n        reverse += '\"';\n        return reverse\n            .split('')\n            .reverse()\n            .join('');\n    }\n    _uvQuoteCmdArg(arg) {\n        // Tool runner wraps child_process.spawn() and needs to apply the same quoting as\n        // Node in certain cases where the undocumented spawn option windowsVerbatimArguments\n        // is used.\n        //\n        // Since this function is a port of quote_cmd_arg from Node 4.x (technically, lib UV,\n        // see https://github.com/nodejs/node/blob/v4.x/deps/uv/src/win/process.c for details),\n        // pasting copyright notice from Node within this function:\n        //\n        //      Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n        //\n        //      Permission is hereby granted, free of charge, to any person obtaining a copy\n        //      of this software and associated documentation files (the \"Software\"), to\n        //      deal in the Software without restriction, including without limitation the\n        //      rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n        //      sell copies of the Software, and to permit persons to whom the Software is\n        //      furnished to do so, subject to the following conditions:\n        //\n        //      The above copyright notice and this permission notice shall be included in\n        //      all copies or substantial portions of the Software.\n        //\n        //      THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        //      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        //      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        //      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        //      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n        //      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n        //      IN THE SOFTWARE.\n        if (!arg) {\n            // Need double quotation for empty argument\n            return '\"\"';\n        }\n        if (!arg.includes(' ') && !arg.includes('\\t') && !arg.includes('\"')) {\n            // No quotation needed\n            return arg;\n        }\n        if (!arg.includes('\"') && !arg.includes('\\\\')) {\n            // No embedded double quotes or backslashes, so I can just wrap\n            // quote marks around the whole thing.\n            return `\"${arg}\"`;\n        }\n        // Expected input/output:\n        //   input : hello\"world\n        //   output: \"hello\\\"world\"\n        //   input : hello\"\"world\n        //   output: \"hello\\\"\\\"world\"\n        //   input : hello\\world\n        //   output: hello\\world\n        //   input : hello\\\\world\n        //   output: hello\\\\world\n        //   input : hello\\\"world\n        //   output: \"hello\\\\\\\"world\"\n        //   input : hello\\\\\"world\n        //   output: \"hello\\\\\\\\\\\"world\"\n        //   input : hello world\\\n        //   output: \"hello world\\\\\" - note the comment in libuv actually reads \"hello world\\\"\n        //                             but it appears the comment is wrong, it should be \"hello world\\\\\"\n        let reverse = '\"';\n        let quoteHit = true;\n        for (let i = arg.length; i > 0; i--) {\n            // walk the string in reverse\n            reverse += arg[i - 1];\n            if (quoteHit && arg[i - 1] === '\\\\') {\n                reverse += '\\\\';\n            }\n            else if (arg[i - 1] === '\"') {\n                quoteHit = true;\n                reverse += '\\\\';\n            }\n            else {\n                quoteHit = false;\n            }\n        }\n        reverse += '\"';\n        return reverse\n            .split('')\n            .reverse()\n            .join('');\n    }\n    _cloneExecOptions(options) {\n        options = options || {};\n        const result = {\n            cwd: options.cwd || process.cwd(),\n            env: options.env || process.env,\n            silent: options.silent || false,\n            windowsVerbatimArguments: options.windowsVerbatimArguments || false,\n            failOnStdErr: options.failOnStdErr || false,\n            ignoreReturnCode: options.ignoreReturnCode || false,\n            delay: options.delay || 10000\n        };\n        result.outStream = options.outStream || process.stdout;\n        result.errStream = options.errStream || process.stderr;\n        return result;\n    }\n    _getSpawnOptions(options, toolPath) {\n        options = options || {};\n        const result = {};\n        result.cwd = options.cwd;\n        result.env = options.env;\n        result['windowsVerbatimArguments'] =\n            options.windowsVerbatimArguments || this._isCmdFile();\n        if (options.windowsVerbatimArguments) {\n            result.argv0 = `\"${toolPath}\"`;\n        }\n        return result;\n    }\n    /**\n     * Exec a tool.\n     * Output will be streamed to the live console.\n     * Returns promise with return code\n     *\n     * @param     tool     path to tool to exec\n     * @param     options  optional exec options.  See ExecOptions\n     * @returns   number\n     */\n    exec() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // root the tool path if it is unrooted and contains relative pathing\n            if (!ioUtil.isRooted(this.toolPath) &&\n                (this.toolPath.includes('/') ||\n                    (IS_WINDOWS && this.toolPath.includes('\\\\')))) {\n                // prefer options.cwd if it is specified, however options.cwd may also need to be rooted\n                this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);\n            }\n            // if the tool is only a file name, then resolve it from the PATH\n            // otherwise verify it exists (add extension on Windows if necessary)\n            this.toolPath = yield io.which(this.toolPath, true);\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                this._debug(`exec tool: ${this.toolPath}`);\n                this._debug('arguments:');\n                for (const arg of this.args) {\n                    this._debug(`   ${arg}`);\n                }\n                const optionsNonNull = this._cloneExecOptions(this.options);\n                if (!optionsNonNull.silent && optionsNonNull.outStream) {\n                    optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);\n                }\n                const state = new ExecState(optionsNonNull, this.toolPath);\n                state.on('debug', (message) => {\n                    this._debug(message);\n                });\n                if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {\n                    return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));\n                }\n                const fileName = this._getSpawnFileName();\n                const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));\n                let stdbuffer = '';\n                if (cp.stdout) {\n                    cp.stdout.on('data', (data) => {\n                        if (this.options.listeners && this.options.listeners.stdout) {\n                            this.options.listeners.stdout(data);\n                        }\n                        if (!optionsNonNull.silent && optionsNonNull.outStream) {\n                            optionsNonNull.outStream.write(data);\n                        }\n                        stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {\n                            if (this.options.listeners && this.options.listeners.stdline) {\n                                this.options.listeners.stdline(line);\n                            }\n                        });\n                    });\n                }\n                let errbuffer = '';\n                if (cp.stderr) {\n                    cp.stderr.on('data', (data) => {\n                        state.processStderr = true;\n                        if (this.options.listeners && this.options.listeners.stderr) {\n                            this.options.listeners.stderr(data);\n                        }\n                        if (!optionsNonNull.silent &&\n                            optionsNonNull.errStream &&\n                            optionsNonNull.outStream) {\n                            const s = optionsNonNull.failOnStdErr\n                                ? optionsNonNull.errStream\n                                : optionsNonNull.outStream;\n                            s.write(data);\n                        }\n                        errbuffer = this._processLineBuffer(data, errbuffer, (line) => {\n                            if (this.options.listeners && this.options.listeners.errline) {\n                                this.options.listeners.errline(line);\n                            }\n                        });\n                    });\n                }\n                cp.on('error', (err) => {\n                    state.processError = err.message;\n                    state.processExited = true;\n                    state.processClosed = true;\n                    state.CheckComplete();\n                });\n                cp.on('exit', (code) => {\n                    state.processExitCode = code;\n                    state.processExited = true;\n                    this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);\n                    state.CheckComplete();\n                });\n                cp.on('close', (code) => {\n                    state.processExitCode = code;\n                    state.processExited = true;\n                    state.processClosed = true;\n                    this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);\n                    state.CheckComplete();\n                });\n                state.on('done', (error, exitCode) => {\n                    if (stdbuffer.length > 0) {\n                        this.emit('stdline', stdbuffer);\n                    }\n                    if (errbuffer.length > 0) {\n                        this.emit('errline', errbuffer);\n                    }\n                    cp.removeAllListeners();\n                    if (error) {\n                        reject(error);\n                    }\n                    else {\n                        resolve(exitCode);\n                    }\n                });\n                if (this.options.input) {\n                    if (!cp.stdin) {\n                        throw new Error('child process missing stdin');\n                    }\n                    cp.stdin.end(this.options.input);\n                }\n            }));\n        });\n    }\n}\nexports.ToolRunner = ToolRunner;\n/**\n * Convert an arg string to an array of args. Handles escaping\n *\n * @param    argString   string of arguments\n * @returns  string[]    array of arguments\n */\nfunction argStringToArray(argString) {\n    const args = [];\n    let inQuotes = false;\n    let escaped = false;\n    let arg = '';\n    function append(c) {\n        // we only escape double quotes.\n        if (escaped && c !== '\"') {\n            arg += '\\\\';\n        }\n        arg += c;\n        escaped = false;\n    }\n    for (let i = 0; i < argString.length; i++) {\n        const c = argString.charAt(i);\n        if (c === '\"') {\n            if (!escaped) {\n                inQuotes = !inQuotes;\n            }\n            else {\n                append(c);\n            }\n            continue;\n        }\n        if (c === '\\\\' && escaped) {\n            append(c);\n            continue;\n        }\n        if (c === '\\\\' && inQuotes) {\n            escaped = true;\n            continue;\n        }\n        if (c === ' ' && !inQuotes) {\n            if (arg.length > 0) {\n                args.push(arg);\n                arg = '';\n            }\n            continue;\n        }\n        append(c);\n    }\n    if (arg.length > 0) {\n        args.push(arg.trim());\n    }\n    return args;\n}\nexports.argStringToArray = argStringToArray;\nclass ExecState extends events.EventEmitter {\n    constructor(options, toolPath) {\n        super();\n        this.processClosed = false; // tracks whether the process has exited and stdio is closed\n        this.processError = '';\n        this.processExitCode = 0;\n        this.processExited = false; // tracks whether the process has exited\n        this.processStderr = false; // tracks whether stderr was written to\n        this.delay = 10000; // 10 seconds\n        this.done = false;\n        this.timeout = null;\n        if (!toolPath) {\n            throw new Error('toolPath must not be empty');\n        }\n        this.options = options;\n        this.toolPath = toolPath;\n        if (options.delay) {\n            this.delay = options.delay;\n        }\n    }\n    CheckComplete() {\n        if (this.done) {\n            return;\n        }\n        if (this.processClosed) {\n            this._setResult();\n        }\n        else if (this.processExited) {\n            this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);\n        }\n    }\n    _debug(message) {\n        this.emit('debug', message);\n    }\n    _setResult() {\n        // determine whether there is an error\n        let error;\n        if (this.processExited) {\n            if (this.processError) {\n                error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);\n            }\n            else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {\n                error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);\n            }\n            else if (this.processStderr && this.options.failOnStdErr) {\n                error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);\n            }\n        }\n        // clear the timeout\n        if (this.timeout) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n        this.done = true;\n        this.emit('done', error, this.processExitCode);\n    }\n    static HandleTimeout(state) {\n        if (state.done) {\n            return;\n        }\n        if (!state.processClosed && state.processExited) {\n            const message = `The STDIO streams did not close within ${state.delay /\n                1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;\n            state._debug(message);\n        }\n        state._setResult();\n    }\n}\n//# sourceMappingURL=toolrunner.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Bearer ${this.token}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n//# sourceMappingURL=auth.js.map","\"use strict\";\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;\nconst http = __importStar(require(\"http\"));\nconst https = __importStar(require(\"https\"));\nconst pm = __importStar(require(\"./proxy\"));\nconst tunnel = __importStar(require(\"tunnel\"));\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                let output = Buffer.alloc(0);\n                this.message.on('data', (chunk) => {\n                    output = Buffer.concat([output, chunk]);\n                });\n                this.message.on('end', () => {\n                    resolve(output.toString());\n                });\n            }));\n        });\n    }\n    readBodyBuffer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                const chunks = [];\n                this.message.on('data', (chunk) => {\n                    chunks.push(chunk);\n                });\n                this.message.on('end', () => {\n                    resolve(Buffer.concat(chunks));\n                });\n            }));\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    const parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    get(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('GET', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    del(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('POST', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PUT', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    head(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(verb, requestUrl, stream, additionalHeaders);\n        });\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    getJson(requestUrl, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            const res = yield this.get(requestUrl, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    postJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.post(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    putJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.put(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    patchJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.patch(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    request(verb, requestUrl, data, headers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._disposed) {\n                throw new Error('Client has already been disposed.');\n            }\n            const parsedUrl = new URL(requestUrl);\n            let info = this._prepareRequest(verb, parsedUrl, headers);\n            // Only perform retries on reads since writes may not be idempotent.\n            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)\n                ? this._maxRetries + 1\n                : 1;\n            let numTries = 0;\n            let response;\n            do {\n                response = yield this.requestRaw(info, data);\n                // Check if it's an authentication challenge\n                if (response &&\n                    response.message &&\n                    response.message.statusCode === HttpCodes.Unauthorized) {\n                    let authenticationHandler;\n                    for (const handler of this.handlers) {\n                        if (handler.canHandleAuthentication(response)) {\n                            authenticationHandler = handler;\n                            break;\n                        }\n                    }\n                    if (authenticationHandler) {\n                        return authenticationHandler.handleAuthentication(this, info, data);\n                    }\n                    else {\n                        // We have received an unauthorized response but have no handlers to handle it.\n                        // Let the response return to the caller.\n                        return response;\n                    }\n                }\n                let redirectsRemaining = this._maxRedirects;\n                while (response.message.statusCode &&\n                    HttpRedirectCodes.includes(response.message.statusCode) &&\n                    this._allowRedirects &&\n                    redirectsRemaining > 0) {\n                    const redirectUrl = response.message.headers['location'];\n                    if (!redirectUrl) {\n                        // if there's no location to redirect to, we won't\n                        break;\n                    }\n                    const parsedRedirectUrl = new URL(redirectUrl);\n                    if (parsedUrl.protocol === 'https:' &&\n                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&\n                        !this._allowRedirectDowngrade) {\n                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                    }\n                    // we need to finish reading the response before reassigning response\n                    // which will leak the open socket.\n                    yield response.readBody();\n                    // strip authorization header if redirected to a different hostname\n                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                        for (const header in headers) {\n                            // header names are case insensitive\n                            if (header.toLowerCase() === 'authorization') {\n                                delete headers[header];\n                            }\n                        }\n                    }\n                    // let's make the request with the new redirectUrl\n                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                    response = yield this.requestRaw(info, data);\n                    redirectsRemaining--;\n                }\n                if (!response.message.statusCode ||\n                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {\n                    // If not a retry code, return immediately instead of retrying\n                    return response;\n                }\n                numTries += 1;\n                if (numTries < maxTries) {\n                    yield response.readBody();\n                    yield this._performExponentialBackoff(numTries);\n                }\n            } while (numTries < maxTries);\n            return response;\n        });\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                function callbackForResult(err, res) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else if (!res) {\n                        // If `err` is not passed, then `res` must be passed.\n                        reject(new Error('Unknown error'));\n                    }\n                    else {\n                        resolve(res);\n                    }\n                }\n                this.requestRawWithCallback(info, data, callbackForResult);\n            });\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        if (typeof data === 'string') {\n            if (!info.options.headers) {\n                info.options.headers = {};\n            }\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        function handleResult(err, res) {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        }\n        const req = info.httpModule.request(info.options, (msg) => {\n            const res = new HttpClientResponse(msg);\n            handleResult(undefined, res);\n        });\n        let socket;\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error(`Request timeout: ${info.options.path}`));\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        const parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            for (const handler of this.handlers) {\n                handler.prepareRequest(info.options);\n            }\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        const proxyUrl = pm.getProxyUrl(parsedUrl);\n        const useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.\n        if (proxyUrl && proxyUrl.hostname) {\n            const agentOptions = {\n                maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {\n                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                })), { host: proxyUrl.hostname, port: proxyUrl.port })\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        return __awaiter(this, void 0, void 0, function* () {\n            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n            return new Promise(resolve => setTimeout(() => resolve(), ms));\n        });\n    }\n    _processResponse(res, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const statusCode = res.message.statusCode || 0;\n                const response = {\n                    statusCode,\n                    result: null,\n                    headers: {}\n                };\n                // not found leads to null obj returned\n                if (statusCode === HttpCodes.NotFound) {\n                    resolve(response);\n                }\n                // get the result from the body\n                function dateTimeDeserializer(key, value) {\n                    if (typeof value === 'string') {\n                        const a = new Date(value);\n                        if (!isNaN(a.valueOf())) {\n                            return a;\n                        }\n                    }\n                    return value;\n                }\n                let obj;\n                let contents;\n                try {\n                    contents = yield res.readBody();\n                    if (contents && contents.length > 0) {\n                        if (options && options.deserializeDates) {\n                            obj = JSON.parse(contents, dateTimeDeserializer);\n                        }\n                        else {\n                            obj = JSON.parse(contents);\n                        }\n                        response.result = obj;\n                    }\n                    response.headers = res.message.headers;\n                }\n                catch (err) {\n                    // Invalid resource (contents not json);  leaving result obj null\n                }\n                // note that 3xx redirects are handled by the http layer.\n                if (statusCode > 299) {\n                    let msg;\n                    // if exception/error in body, attempt to get better error\n                    if (obj && obj.message) {\n                        msg = obj.message;\n                    }\n                    else if (contents && contents.length > 0) {\n                        // it may be the case that the exception is in the body message as string\n                        msg = contents;\n                    }\n                    else {\n                        msg = `Failed request: (${statusCode})`;\n                    }\n                    const err = new HttpClientError(msg, statusCode);\n                    err.result = response.result;\n                    reject(err);\n                }\n                else {\n                    resolve(response);\n                }\n            }));\n        });\n    }\n}\nexports.HttpClient = HttpClient;\nconst lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkBypass = exports.getProxyUrl = void 0;\nfunction getProxyUrl(reqUrl) {\n    const usingSsl = reqUrl.protocol === 'https:';\n    if (checkBypass(reqUrl)) {\n        return undefined;\n    }\n    const proxyVar = (() => {\n        if (usingSsl) {\n            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n        }\n        else {\n            return process.env['http_proxy'] || process.env['HTTP_PROXY'];\n        }\n    })();\n    if (proxyVar) {\n        try {\n            return new URL(proxyVar);\n        }\n        catch (_a) {\n            if (!proxyVar.startsWith('http://') && !proxyVar.startsWith('https://'))\n                return new URL(`http://${proxyVar}`);\n        }\n    }\n    else {\n        return undefined;\n    }\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    const reqHost = reqUrl.hostname;\n    if (isLoopbackAddress(reqHost)) {\n        return true;\n    }\n    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    const upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (const upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperNoProxyItem === '*' ||\n            upperReqHosts.some(x => x === upperNoProxyItem ||\n                x.endsWith(`.${upperNoProxyItem}`) ||\n                (upperNoProxyItem.startsWith('.') &&\n                    x.endsWith(`${upperNoProxyItem}`)))) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\nfunction isLoopbackAddress(host) {\n    const hostLower = host.toLowerCase();\n    return (hostLower === 'localhost' ||\n        hostLower.startsWith('127.') ||\n        hostLower.startsWith('[::1]') ||\n        hostLower.startsWith('[0:0:0:0:0:0:0:1]'));\n}\n//# sourceMappingURL=proxy.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst path = __importStar(require(\"path\"));\n_a = fs.promises\n// export const {open} = 'fs'\n, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;\n// export const {open} = 'fs'\nexports.IS_WINDOWS = process.platform === 'win32';\n// See https://github.com/nodejs/node/blob/d0153aee367422d0858105abec186da4dff0a0c5/deps/uv/include/uv/win.h#L691\nexports.UV_FS_O_EXLOCK = 0x10000000;\nexports.READONLY = fs.constants.O_RDONLY;\nfunction exists(fsPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            yield exports.stat(fsPath);\n        }\n        catch (err) {\n            if (err.code === 'ENOENT') {\n                return false;\n            }\n            throw err;\n        }\n        return true;\n    });\n}\nexports.exists = exists;\nfunction isDirectory(fsPath, useStat = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);\n        return stats.isDirectory();\n    });\n}\nexports.isDirectory = isDirectory;\n/**\n * On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:\n * \\, \\hello, \\\\hello\\share, C:, and C:\\hello (and corresponding alternate separator cases).\n */\nfunction isRooted(p) {\n    p = normalizeSeparators(p);\n    if (!p) {\n        throw new Error('isRooted() parameter \"p\" cannot be empty');\n    }\n    if (exports.IS_WINDOWS) {\n        return (p.startsWith('\\\\') || /^[A-Z]:/i.test(p) // e.g. \\ or \\hello or \\\\hello\n        ); // e.g. C: or C:\\hello\n    }\n    return p.startsWith('/');\n}\nexports.isRooted = isRooted;\n/**\n * Best effort attempt to determine whether a file exists and is executable.\n * @param filePath    file path to check\n * @param extensions  additional file extensions to try\n * @return if file exists and is executable, returns the file path. otherwise empty string.\n */\nfunction tryGetExecutablePath(filePath, extensions) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let stats = undefined;\n        try {\n            // test file exists\n            stats = yield exports.stat(filePath);\n        }\n        catch (err) {\n            if (err.code !== 'ENOENT') {\n                // eslint-disable-next-line no-console\n                console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);\n            }\n        }\n        if (stats && stats.isFile()) {\n            if (exports.IS_WINDOWS) {\n                // on Windows, test for valid extension\n                const upperExt = path.extname(filePath).toUpperCase();\n                if (extensions.some(validExt => validExt.toUpperCase() === upperExt)) {\n                    return filePath;\n                }\n            }\n            else {\n                if (isUnixExecutable(stats)) {\n                    return filePath;\n                }\n            }\n        }\n        // try each extension\n        const originalFilePath = filePath;\n        for (const extension of extensions) {\n            filePath = originalFilePath + extension;\n            stats = undefined;\n            try {\n                stats = yield exports.stat(filePath);\n            }\n            catch (err) {\n                if (err.code !== 'ENOENT') {\n                    // eslint-disable-next-line no-console\n                    console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);\n                }\n            }\n            if (stats && stats.isFile()) {\n                if (exports.IS_WINDOWS) {\n                    // preserve the case of the actual file (since an extension was appended)\n                    try {\n                        const directory = path.dirname(filePath);\n                        const upperName = path.basename(filePath).toUpperCase();\n                        for (const actualName of yield exports.readdir(directory)) {\n                            if (upperName === actualName.toUpperCase()) {\n                                filePath = path.join(directory, actualName);\n                                break;\n                            }\n                        }\n                    }\n                    catch (err) {\n                        // eslint-disable-next-line no-console\n                        console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);\n                    }\n                    return filePath;\n                }\n                else {\n                    if (isUnixExecutable(stats)) {\n                        return filePath;\n                    }\n                }\n            }\n        }\n        return '';\n    });\n}\nexports.tryGetExecutablePath = tryGetExecutablePath;\nfunction normalizeSeparators(p) {\n    p = p || '';\n    if (exports.IS_WINDOWS) {\n        // convert slashes on Windows\n        p = p.replace(/\\//g, '\\\\');\n        // remove redundant slashes\n        return p.replace(/\\\\\\\\+/g, '\\\\');\n    }\n    // remove redundant slashes\n    return p.replace(/\\/\\/+/g, '/');\n}\n// on Mac/Linux, test the execute bit\n//     R   W  X  R  W X R W X\n//   256 128 64 32 16 8 4 2 1\nfunction isUnixExecutable(stats) {\n    return ((stats.mode & 1) > 0 ||\n        ((stats.mode & 8) > 0 && stats.gid === process.getgid()) ||\n        ((stats.mode & 64) > 0 && stats.uid === process.getuid()));\n}\n// Get the path of cmd.exe in windows\nfunction getCmdPath() {\n    var _a;\n    return (_a = process.env['COMSPEC']) !== null && _a !== void 0 ? _a : `cmd.exe`;\n}\nexports.getCmdPath = getCmdPath;\n//# sourceMappingURL=io-util.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;\nconst assert_1 = require(\"assert\");\nconst path = __importStar(require(\"path\"));\nconst ioUtil = __importStar(require(\"./io-util\"));\n/**\n * Copies a file or folder.\n * Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js\n *\n * @param     source    source path\n * @param     dest      destination path\n * @param     options   optional. See CopyOptions.\n */\nfunction cp(source, dest, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { force, recursive, copySourceDirectory } = readCopyOptions(options);\n        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;\n        // Dest is an existing file, but not forcing\n        if (destStat && destStat.isFile() && !force) {\n            return;\n        }\n        // If dest is an existing directory, should copy inside.\n        const newDest = destStat && destStat.isDirectory() && copySourceDirectory\n            ? path.join(dest, path.basename(source))\n            : dest;\n        if (!(yield ioUtil.exists(source))) {\n            throw new Error(`no such file or directory: ${source}`);\n        }\n        const sourceStat = yield ioUtil.stat(source);\n        if (sourceStat.isDirectory()) {\n            if (!recursive) {\n                throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);\n            }\n            else {\n                yield cpDirRecursive(source, newDest, 0, force);\n            }\n        }\n        else {\n            if (path.relative(source, newDest) === '') {\n                // a file cannot be copied to itself\n                throw new Error(`'${newDest}' and '${source}' are the same file`);\n            }\n            yield copyFile(source, newDest, force);\n        }\n    });\n}\nexports.cp = cp;\n/**\n * Moves a path.\n *\n * @param     source    source path\n * @param     dest      destination path\n * @param     options   optional. See MoveOptions.\n */\nfunction mv(source, dest, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (yield ioUtil.exists(dest)) {\n            let destExists = true;\n            if (yield ioUtil.isDirectory(dest)) {\n                // If dest is directory copy src into dest\n                dest = path.join(dest, path.basename(source));\n                destExists = yield ioUtil.exists(dest);\n            }\n            if (destExists) {\n                if (options.force == null || options.force) {\n                    yield rmRF(dest);\n                }\n                else {\n                    throw new Error('Destination already exists');\n                }\n            }\n        }\n        yield mkdirP(path.dirname(dest));\n        yield ioUtil.rename(source, dest);\n    });\n}\nexports.mv = mv;\n/**\n * Remove a path recursively with force\n *\n * @param inputPath path to remove\n */\nfunction rmRF(inputPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (ioUtil.IS_WINDOWS) {\n            // Check for invalid characters\n            // https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file\n            if (/[*\"<>|]/.test(inputPath)) {\n                throw new Error('File path must not contain `*`, `\"`, `<`, `>` or `|` on Windows');\n            }\n        }\n        try {\n            // note if path does not exist, error is silent\n            yield ioUtil.rm(inputPath, {\n                force: true,\n                maxRetries: 3,\n                recursive: true,\n                retryDelay: 300\n            });\n        }\n        catch (err) {\n            throw new Error(`File was unable to be removed ${err}`);\n        }\n    });\n}\nexports.rmRF = rmRF;\n/**\n * Make a directory.  Creates the full path with folders in between\n * Will throw if it fails\n *\n * @param   fsPath        path to create\n * @returns Promise<void>\n */\nfunction mkdirP(fsPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assert_1.ok(fsPath, 'a path argument must be provided');\n        yield ioUtil.mkdir(fsPath, { recursive: true });\n    });\n}\nexports.mkdirP = mkdirP;\n/**\n * Returns path of a tool had the tool actually been invoked.  Resolves via paths.\n * If you check and the tool does not exist, it will throw.\n *\n * @param     tool              name of the tool\n * @param     check             whether to check if tool exists\n * @returns   Promise<string>   path to tool\n */\nfunction which(tool, check) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!tool) {\n            throw new Error(\"parameter 'tool' is required\");\n        }\n        // recursive when check=true\n        if (check) {\n            const result = yield which(tool, false);\n            if (!result) {\n                if (ioUtil.IS_WINDOWS) {\n                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);\n                }\n                else {\n                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);\n                }\n            }\n            return result;\n        }\n        const matches = yield findInPath(tool);\n        if (matches && matches.length > 0) {\n            return matches[0];\n        }\n        return '';\n    });\n}\nexports.which = which;\n/**\n * Returns a list of all occurrences of the given tool on the system path.\n *\n * @returns   Promise<string[]>  the paths of the tool\n */\nfunction findInPath(tool) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!tool) {\n            throw new Error(\"parameter 'tool' is required\");\n        }\n        // build the list of extensions to try\n        const extensions = [];\n        if (ioUtil.IS_WINDOWS && process.env['PATHEXT']) {\n            for (const extension of process.env['PATHEXT'].split(path.delimiter)) {\n                if (extension) {\n                    extensions.push(extension);\n                }\n            }\n        }\n        // if it's rooted, return it if exists. otherwise return empty.\n        if (ioUtil.isRooted(tool)) {\n            const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);\n            if (filePath) {\n                return [filePath];\n            }\n            return [];\n        }\n        // if any path separators, return empty\n        if (tool.includes(path.sep)) {\n            return [];\n        }\n        // build the list of directories\n        //\n        // Note, technically \"where\" checks the current directory on Windows. From a toolkit perspective,\n        // it feels like we should not do this. Checking the current directory seems like more of a use\n        // case of a shell, and the which() function exposed by the toolkit should strive for consistency\n        // across platforms.\n        const directories = [];\n        if (process.env.PATH) {\n            for (const p of process.env.PATH.split(path.delimiter)) {\n                if (p) {\n                    directories.push(p);\n                }\n            }\n        }\n        // find all matches\n        const matches = [];\n        for (const directory of directories) {\n            const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);\n            if (filePath) {\n                matches.push(filePath);\n            }\n        }\n        return matches;\n    });\n}\nexports.findInPath = findInPath;\nfunction readCopyOptions(options) {\n    const force = options.force == null ? true : options.force;\n    const recursive = Boolean(options.recursive);\n    const copySourceDirectory = options.copySourceDirectory == null\n        ? true\n        : Boolean(options.copySourceDirectory);\n    return { force, recursive, copySourceDirectory };\n}\nfunction cpDirRecursive(sourceDir, destDir, currentDepth, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Ensure there is not a run away recursive copy\n        if (currentDepth >= 255)\n            return;\n        currentDepth++;\n        yield mkdirP(destDir);\n        const files = yield ioUtil.readdir(sourceDir);\n        for (const fileName of files) {\n            const srcFile = `${sourceDir}/${fileName}`;\n            const destFile = `${destDir}/${fileName}`;\n            const srcFileStat = yield ioUtil.lstat(srcFile);\n            if (srcFileStat.isDirectory()) {\n                // Recurse\n                yield cpDirRecursive(srcFile, destFile, currentDepth, force);\n            }\n            else {\n                yield copyFile(srcFile, destFile, force);\n            }\n        }\n        // Change the mode for the newly created directory\n        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);\n    });\n}\n// Buffered file copy\nfunction copyFile(srcFile, destFile, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {\n            // unlink/re-link it\n            try {\n                yield ioUtil.lstat(destFile);\n                yield ioUtil.unlink(destFile);\n            }\n            catch (e) {\n                // Try to override file permission\n                if (e.code === 'EPERM') {\n                    yield ioUtil.chmod(destFile, '0666');\n                    yield ioUtil.unlink(destFile);\n                }\n                // other errors = it doesn't exist, no work to do\n            }\n            // Copy over symlink\n            const symlinkFull = yield ioUtil.readlink(srcFile);\n            yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? 'junction' : null);\n        }\n        else if (!(yield ioUtil.exists(destFile)) || force) {\n            yield ioUtil.copyFile(srcFile, destFile);\n        }\n    });\n}\n//# sourceMappingURL=io.js.map","\"use strict\";\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArchiveReader = void 0;\n/* eslint-disable no-underscore-dangle */\nvar ArchiveReaderEntry_1 = require(\"./ArchiveReaderEntry\");\n/**\n * Specifies how many milliseconds make up a second.\n *\n * This constant allows the conversion of the C `time_t` type into JavaScript-friendly `Date` time.\n */\nvar ONE_SEC_IN_MS = 1000;\nvar ArchiveReader = /** @class */ (function () {\n    function ArchiveReader(libarchive, data, passphrase) {\n        var ptr = libarchive.module._malloc(data.length);\n        libarchive.module.HEAP8.set(data, ptr);\n        this.libarchive = libarchive;\n        this.archive = libarchive.read_new_memory(ptr, data.length, passphrase);\n        this.pointer = ptr;\n    }\n    ArchiveReader.prototype.free = function () {\n        this.libarchive.read_free(this.archive);\n        this.libarchive.module._free(this.pointer);\n        this.libarchive = null;\n        this.archive = null;\n        this.pointer = null;\n    };\n    ArchiveReader.prototype.hasEncryptedData = function () {\n        var code = this.libarchive.read_has_encrypted_entries(this.archive);\n        return code < 0 ? null : !!code;\n    };\n    ArchiveReader.prototype.readData = function (size) {\n        var eptr = this.libarchive.module._malloc(size);\n        var esize = this.libarchive.read_data(this.archive, eptr, size);\n        var data = this.libarchive.module.HEAP8.slice(eptr, eptr + esize);\n        this.libarchive.module._free(eptr);\n        return data;\n    };\n    ArchiveReader.prototype.skipData = function () {\n        this.libarchive.read_data_skip(this.archive);\n    };\n    ArchiveReader.prototype.nextEntryPointer = function () {\n        return this.libarchive.read_next_entry(this.archive);\n    };\n    ArchiveReader.prototype.getEntryFiletype = function (ptr) {\n        return ArchiveReader.FileTypes[\"\".concat(this.libarchive.entry_filetype(ptr))] || 'Invalid';\n    };\n    ArchiveReader.prototype.getEntryPathname = function (ptr) {\n        return this.libarchive.entry_pathname(ptr);\n    };\n    ArchiveReader.prototype.getEntrySize = function (ptr) {\n        return this.libarchive.entry_size(ptr);\n    };\n    ArchiveReader.prototype.getCreationTime = function (ptr) {\n        return this.libarchive.entry_ctime(ptr) * ONE_SEC_IN_MS; // convert secs to ms\n    };\n    ArchiveReader.prototype.getModificationTime = function (ptr) {\n        return this.libarchive.entry_mtime(ptr) * ONE_SEC_IN_MS; // convert secs to ms\n    };\n    ArchiveReader.prototype.isEntryEncrypted = function (ptr) {\n        return !!this.libarchive.entry_is_encrypted(ptr);\n    };\n    ArchiveReader.prototype.getSymlinkTarget = function (ptr) {\n        return this.libarchive.entry_symlink(ptr);\n    };\n    ArchiveReader.prototype.getHardlinkTarget = function (ptr) {\n        return this.libarchive.entry_hardlink(ptr);\n    };\n    ArchiveReader.prototype.nextEntry = function () {\n        var entryPtr = this.nextEntryPointer();\n        if (entryPtr === 0)\n            return null;\n        return new ArchiveReaderEntry_1.ArchiveReaderEntry(this, entryPtr);\n    };\n    ArchiveReader.prototype.forEach = function (fn) {\n        for (;;) {\n            var entry = this.nextEntry();\n            if (!entry)\n                break;\n            fn(entry);\n            entry.free();\n        }\n    };\n    ArchiveReader.prototype.entries = function () {\n        var entry;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    entry = this.nextEntry();\n                    if (!entry)\n                        return [3 /*break*/, 3];\n                    return [4 /*yield*/, entry];\n                case 1:\n                    _a.sent();\n                    entry.free();\n                    _a.label = 2;\n                case 2: return [3 /*break*/, 0];\n                case 3: return [2 /*return*/];\n            }\n        });\n    };\n    ArchiveReader.FileTypes = (_a = {},\n        _a[\"\".concat(61440)] = 'Mount',\n        _a[\"\".concat(32768)] = 'File',\n        _a[\"\".concat(40960)] = 'SymbolicLink',\n        _a[\"\".concat(49152)] = 'Socket',\n        _a[\"\".concat(8192)] = 'CharacterDevice',\n        _a[\"\".concat(24576)] = 'BlockDevice',\n        _a[\"\".concat(16384)] = 'Directory',\n        _a[\"\".concat(4096)] = 'NamedPipe',\n        _a);\n    return ArchiveReader;\n}());\nexports.ArchiveReader = ArchiveReader;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArchiveReaderEntry = void 0;\nvar ArchiveReaderEntry = /** @class */ (function () {\n    function ArchiveReaderEntry(reader, ptr) {\n        this.reader = reader;\n        this.pointer = ptr;\n        this.readCalled = false;\n    }\n    ArchiveReaderEntry.prototype.free = function () {\n        this.skipData();\n        this.reader = null;\n        this.pointer = null;\n    };\n    ArchiveReaderEntry.prototype.readData = function () {\n        if (this.readCalled)\n            throw new Error('It has already been called.');\n        var size = this.getSize();\n        if (!size) {\n            this.skipData();\n            return undefined;\n        }\n        this.readCalled = true;\n        return this.reader.readData(size);\n    };\n    ArchiveReaderEntry.prototype.skipData = function () {\n        if (this.readCalled)\n            return;\n        this.readCalled = true;\n        this.reader.skipData();\n    };\n    ArchiveReaderEntry.prototype.getFiletype = function () {\n        return this.reader.getEntryFiletype(this.pointer);\n    };\n    ArchiveReaderEntry.prototype.getPathname = function () {\n        return this.reader.getEntryPathname(this.pointer);\n    };\n    ArchiveReaderEntry.prototype.getSize = function () {\n        return this.reader.getEntrySize(this.pointer);\n    };\n    ArchiveReaderEntry.prototype.getCreationTime = function () {\n        return this.reader.getCreationTime(this.pointer);\n    };\n    ArchiveReaderEntry.prototype.getModificationTime = function () {\n        return this.reader.getModificationTime(this.pointer);\n    };\n    ArchiveReaderEntry.prototype.isEncrypted = function () {\n        return this.reader.isEntryEncrypted(this.pointer);\n    };\n    ArchiveReaderEntry.prototype.getSymlinkTarget = function () {\n        return this.reader.getSymlinkTarget(this.pointer);\n    };\n    ArchiveReaderEntry.prototype.getHardlinkTarget = function () {\n        return this.reader.getHardlinkTarget(this.pointer);\n    };\n    return ArchiveReaderEntry;\n}());\nexports.ArchiveReaderEntry = ArchiveReaderEntry;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.libarchive = void 0;\nvar libarchive_1 = __importDefault(require(\"./libarchive\"));\nexports.libarchive = libarchive_1.default;\n__exportStar(require(\"./libarchiveWasm\"), exports);\n__exportStar(require(\"./wrapLibarchiveWasm\"), exports);\n__exportStar(require(\"./ArchiveReader\"), exports);\n","\"use strict\";\nvar libarchive = (function () {\n    var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n    if (typeof __filename !== 'undefined')\n        _scriptDir = _scriptDir || __filename;\n    return (function (moduleArg) {\n        if (moduleArg === void 0) { moduleArg = {}; }\n        var Module = moduleArg;\n        var readyPromiseResolve, readyPromiseReject;\n        Module[\"ready\"] = new Promise((function (resolve, reject) { readyPromiseResolve = resolve; readyPromiseReject = reject; }));\n        var moduleOverrides = Object.assign({}, Module);\n        var arguments_ = [];\n        var thisProgram = \"./this.program\";\n        var quit_ = function (status, toThrow) { throw toThrow; };\n        var ENVIRONMENT_IS_WEB = typeof window == \"object\";\n        var ENVIRONMENT_IS_WORKER = typeof importScripts == \"function\";\n        var ENVIRONMENT_IS_NODE = typeof process == \"object\" && typeof process.versions == \"object\" && typeof process.versions.node == \"string\";\n        var scriptDirectory = \"\";\n        function locateFile(path) { if (Module[\"locateFile\"]) {\n            return Module[\"locateFile\"](path, scriptDirectory);\n        } return scriptDirectory + path; }\n        var read_, readAsync, readBinary, setWindowTitle;\n        if (ENVIRONMENT_IS_NODE) {\n            var fs = require(\"fs\");\n            var nodePath = require(\"path\");\n            if (ENVIRONMENT_IS_WORKER) {\n                scriptDirectory = nodePath.dirname(scriptDirectory) + \"/\";\n            }\n            else {\n                scriptDirectory = __dirname + \"/\";\n            }\n            read_ = function (filename, binary) { filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename); return fs.readFileSync(filename, binary ? undefined : \"utf8\"); };\n            readBinary = function (filename) { var ret = read_(filename, true); if (!ret.buffer) {\n                ret = new Uint8Array(ret);\n            } return ret; };\n            readAsync = function (filename, onload, onerror, binary) {\n                if (binary === void 0) { binary = true; }\n                filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\n                fs.readFile(filename, binary ? undefined : \"utf8\", (function (err, data) { if (err)\n                    onerror(err);\n                else\n                    onload(binary ? data.buffer : data); }));\n            };\n            if (!Module[\"thisProgram\"] && process.argv.length > 1) {\n                thisProgram = process.argv[1].replace(/\\\\/g, \"/\");\n            }\n            arguments_ = process.argv.slice(2);\n            quit_ = function (status, toThrow) { process.exitCode = status; throw toThrow; };\n            Module[\"inspect\"] = function () { return \"[Emscripten Module object]\"; };\n        }\n        else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n            if (ENVIRONMENT_IS_WORKER) {\n                scriptDirectory = self.location.href;\n            }\n            else if (typeof document != \"undefined\" && document.currentScript) {\n                scriptDirectory = document.currentScript.src;\n            }\n            if (_scriptDir) {\n                scriptDirectory = _scriptDir;\n            }\n            if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n                scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n            }\n            else {\n                scriptDirectory = \"\";\n            }\n            {\n                read_ = function (url) { var xhr = new XMLHttpRequest; xhr.open(\"GET\", url, false); xhr.send(null); return xhr.responseText; };\n                if (ENVIRONMENT_IS_WORKER) {\n                    readBinary = function (url) { var xhr = new XMLHttpRequest; xhr.open(\"GET\", url, false); xhr.responseType = \"arraybuffer\"; xhr.send(null); return new Uint8Array(xhr.response); };\n                }\n                readAsync = function (url, onload, onerror) { var xhr = new XMLHttpRequest; xhr.open(\"GET\", url, true); xhr.responseType = \"arraybuffer\"; xhr.onload = function () { if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n                    onload(xhr.response);\n                    return;\n                } onerror(); }; xhr.onerror = onerror; xhr.send(null); };\n            }\n            setWindowTitle = function (title) { return document.title = title; };\n        }\n        else { }\n        var out = Module[\"print\"] || console.log.bind(console);\n        var err = Module[\"printErr\"] || console.error.bind(console);\n        Object.assign(Module, moduleOverrides);\n        moduleOverrides = null;\n        if (Module[\"arguments\"])\n            arguments_ = Module[\"arguments\"];\n        if (Module[\"thisProgram\"])\n            thisProgram = Module[\"thisProgram\"];\n        if (Module[\"quit\"])\n            quit_ = Module[\"quit\"];\n        var wasmBinary;\n        if (Module[\"wasmBinary\"])\n            wasmBinary = Module[\"wasmBinary\"];\n        var noExitRuntime = Module[\"noExitRuntime\"] || true;\n        if (typeof WebAssembly != \"object\") {\n            abort(\"no native wasm support detected\");\n        }\n        var wasmMemory;\n        var ABORT = false;\n        var EXITSTATUS;\n        function assert(condition, text) { if (!condition) {\n            abort(text);\n        } }\n        var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n        function updateMemoryViews() { var b = wasmMemory.buffer; Module[\"HEAP8\"] = HEAP8 = new Int8Array(b); Module[\"HEAP16\"] = HEAP16 = new Int16Array(b); Module[\"HEAP32\"] = HEAP32 = new Int32Array(b); Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b); Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b); Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b); Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b); Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b); }\n        var wasmTable;\n        var __ATPRERUN__ = [];\n        var __ATINIT__ = [];\n        var __ATPOSTRUN__ = [];\n        var runtimeInitialized = false;\n        var runtimeKeepaliveCounter = 0;\n        function keepRuntimeAlive() { return noExitRuntime || runtimeKeepaliveCounter > 0; }\n        function preRun() { if (Module[\"preRun\"]) {\n            if (typeof Module[\"preRun\"] == \"function\")\n                Module[\"preRun\"] = [Module[\"preRun\"]];\n            while (Module[\"preRun\"].length) {\n                addOnPreRun(Module[\"preRun\"].shift());\n            }\n        } callRuntimeCallbacks(__ATPRERUN__); }\n        function initRuntime() { runtimeInitialized = true; if (!Module[\"noFSInit\"] && !FS.init.initialized)\n            FS.init(); FS.ignorePermissions = false; TTY.init(); PIPEFS.root = FS.mount(PIPEFS, {}, null); callRuntimeCallbacks(__ATINIT__); }\n        function postRun() { if (Module[\"postRun\"]) {\n            if (typeof Module[\"postRun\"] == \"function\")\n                Module[\"postRun\"] = [Module[\"postRun\"]];\n            while (Module[\"postRun\"].length) {\n                addOnPostRun(Module[\"postRun\"].shift());\n            }\n        } callRuntimeCallbacks(__ATPOSTRUN__); }\n        function addOnPreRun(cb) { __ATPRERUN__.unshift(cb); }\n        function addOnInit(cb) { __ATINIT__.unshift(cb); }\n        function addOnPostRun(cb) { __ATPOSTRUN__.unshift(cb); }\n        var runDependencies = 0;\n        var runDependencyWatcher = null;\n        var dependenciesFulfilled = null;\n        function getUniqueRunDependency(id) { return id; }\n        function addRunDependency(id) { runDependencies++; if (Module[\"monitorRunDependencies\"]) {\n            Module[\"monitorRunDependencies\"](runDependencies);\n        } }\n        function removeRunDependency(id) { runDependencies--; if (Module[\"monitorRunDependencies\"]) {\n            Module[\"monitorRunDependencies\"](runDependencies);\n        } if (runDependencies == 0) {\n            if (runDependencyWatcher !== null) {\n                clearInterval(runDependencyWatcher);\n                runDependencyWatcher = null;\n            }\n            if (dependenciesFulfilled) {\n                var callback = dependenciesFulfilled;\n                dependenciesFulfilled = null;\n                callback();\n            }\n        } }\n        function abort(what) { if (Module[\"onAbort\"]) {\n            Module[\"onAbort\"](what);\n        } what = \"Aborted(\" + what + \")\"; err(what); ABORT = true; EXITSTATUS = 1; what += \". Build with -sASSERTIONS for more info.\"; var e = new WebAssembly.RuntimeError(what); readyPromiseReject(e); throw e; }\n        var dataURIPrefix = \"data:application/octet-stream;base64,\";\n        function isDataURI(filename) { return filename.startsWith(dataURIPrefix); }\n        function isFileURI(filename) { return filename.startsWith(\"file://\"); }\n        var wasmBinaryFile;\n        wasmBinaryFile = \"libarchive.wasm\";\n        if (!isDataURI(wasmBinaryFile)) {\n            wasmBinaryFile = locateFile(wasmBinaryFile);\n        }\n        function getBinarySync(file) { if (file == wasmBinaryFile && wasmBinary) {\n            return new Uint8Array(wasmBinary);\n        } if (readBinary) {\n            return readBinary(file);\n        } throw \"both async and sync fetching of the wasm failed\"; }\n        function getBinaryPromise(binaryFile) { if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n            if (typeof fetch == \"function\" && !isFileURI(binaryFile)) {\n                return fetch(binaryFile, { credentials: \"same-origin\" }).then((function (response) { if (!response[\"ok\"]) {\n                    throw \"failed to load wasm binary file at '\" + binaryFile + \"'\";\n                } return response[\"arrayBuffer\"](); })).catch((function () { return getBinarySync(binaryFile); }));\n            }\n            else if (readAsync) {\n                return new Promise((function (resolve, reject) { readAsync(binaryFile, (function (response) { return resolve(new Uint8Array(response)); }), reject); }));\n            }\n        } return Promise.resolve().then((function () { return getBinarySync(binaryFile); })); }\n        function instantiateArrayBuffer(binaryFile, imports, receiver) { return getBinaryPromise(binaryFile).then((function (binary) { return WebAssembly.instantiate(binary, imports); })).then((function (instance) { return instance; })).then(receiver, (function (reason) { err(\"failed to asynchronously prepare wasm: \" + reason); abort(reason); })); }\n        function instantiateAsync(binary, binaryFile, imports, callback) { if (!binary && typeof WebAssembly.instantiateStreaming == \"function\" && !isDataURI(binaryFile) && !isFileURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == \"function\") {\n            return fetch(binaryFile, { credentials: \"same-origin\" }).then((function (response) { var result = WebAssembly.instantiateStreaming(response, imports); return result.then(callback, (function (reason) { err(\"wasm streaming compile failed: \" + reason); err(\"falling back to ArrayBuffer instantiation\"); return instantiateArrayBuffer(binaryFile, imports, callback); })); }));\n        } return instantiateArrayBuffer(binaryFile, imports, callback); }\n        function createWasm() { var info = { \"a\": wasmImports }; function receiveInstance(instance, module) { var exports = instance.exports; Module[\"asm\"] = exports; wasmMemory = Module[\"asm\"][\"x\"]; updateMemoryViews(); wasmTable = Module[\"asm\"][\"G\"]; addOnInit(Module[\"asm\"][\"y\"]); removeRunDependency(\"wasm-instantiate\"); return exports; } addRunDependency(\"wasm-instantiate\"); function receiveInstantiationResult(result) { receiveInstance(result[\"instance\"]); } if (Module[\"instantiateWasm\"]) {\n            try {\n                return Module[\"instantiateWasm\"](info, receiveInstance);\n            }\n            catch (e) {\n                err(\"Module.instantiateWasm callback failed with error: \" + e);\n                readyPromiseReject(e);\n            }\n        } instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject); return {}; }\n        var tempDouble;\n        var tempI64;\n        function ExitStatus(status) { this.name = \"ExitStatus\"; this.message = \"Program terminated with exit(\".concat(status, \")\"); this.status = status; }\n        var callRuntimeCallbacks = function (callbacks) { while (callbacks.length > 0) {\n            callbacks.shift()(Module);\n        } };\n        var PATH = { isAbs: function (path) { return path.charAt(0) === \"/\"; }, splitPath: function (filename) { var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/; return splitPathRe.exec(filename).slice(1); }, normalizeArray: function (parts, allowAboveRoot) { var up = 0; for (var i = parts.length - 1; i >= 0; i--) {\n                var last = parts[i];\n                if (last === \".\") {\n                    parts.splice(i, 1);\n                }\n                else if (last === \"..\") {\n                    parts.splice(i, 1);\n                    up++;\n                }\n                else if (up) {\n                    parts.splice(i, 1);\n                    up--;\n                }\n            } if (allowAboveRoot) {\n                for (; up; up--) {\n                    parts.unshift(\"..\");\n                }\n            } return parts; }, normalize: function (path) { var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === \"/\"; path = PATH.normalizeArray(path.split(\"/\").filter((function (p) { return !!p; })), !isAbsolute).join(\"/\"); if (!path && !isAbsolute) {\n                path = \".\";\n            } if (path && trailingSlash) {\n                path += \"/\";\n            } return (isAbsolute ? \"/\" : \"\") + path; }, dirname: function (path) { var result = PATH.splitPath(path), root = result[0], dir = result[1]; if (!root && !dir) {\n                return \".\";\n            } if (dir) {\n                dir = dir.substr(0, dir.length - 1);\n            } return root + dir; }, basename: function (path) { if (path === \"/\")\n                return \"/\"; path = PATH.normalize(path); path = path.replace(/\\/$/, \"\"); var lastSlash = path.lastIndexOf(\"/\"); if (lastSlash === -1)\n                return path; return path.substr(lastSlash + 1); }, join: function () { var paths = Array.prototype.slice.call(arguments); return PATH.normalize(paths.join(\"/\")); }, join2: function (l, r) { return PATH.normalize(l + \"/\" + r); } };\n        var initRandomFill = function () { if (typeof crypto == \"object\" && typeof crypto[\"getRandomValues\"] == \"function\") {\n            return function (view) { return crypto.getRandomValues(view); };\n        }\n        else if (ENVIRONMENT_IS_NODE) {\n            try {\n                var crypto_module = require(\"crypto\");\n                var randomFillSync = crypto_module[\"randomFillSync\"];\n                if (randomFillSync) {\n                    return function (view) { return crypto_module[\"randomFillSync\"](view); };\n                }\n                var randomBytes = crypto_module[\"randomBytes\"];\n                return function (view) { return (view.set(randomBytes(view.byteLength)), view); };\n            }\n            catch (e) { }\n        } abort(\"initRandomDevice\"); };\n        var randomFill = function (view) { return (randomFill = initRandomFill())(view); };\n        var PATH_FS = { resolve: function () { var resolvedPath = \"\", resolvedAbsolute = false; for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n                var path = i >= 0 ? arguments[i] : FS.cwd();\n                if (typeof path != \"string\") {\n                    throw new TypeError(\"Arguments to path.resolve must be strings\");\n                }\n                else if (!path) {\n                    return \"\";\n                }\n                resolvedPath = path + \"/\" + resolvedPath;\n                resolvedAbsolute = PATH.isAbs(path);\n            } resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter((function (p) { return !!p; })), !resolvedAbsolute).join(\"/\"); return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\"; }, relative: function (from, to) { from = PATH_FS.resolve(from).substr(1); to = PATH_FS.resolve(to).substr(1); function trim(arr) { var start = 0; for (; start < arr.length; start++) {\n                if (arr[start] !== \"\")\n                    break;\n            } var end = arr.length - 1; for (; end >= 0; end--) {\n                if (arr[end] !== \"\")\n                    break;\n            } if (start > end)\n                return []; return arr.slice(start, end - start + 1); } var fromParts = trim(from.split(\"/\")); var toParts = trim(to.split(\"/\")); var length = Math.min(fromParts.length, toParts.length); var samePartsLength = length; for (var i = 0; i < length; i++) {\n                if (fromParts[i] !== toParts[i]) {\n                    samePartsLength = i;\n                    break;\n                }\n            } var outputParts = []; for (var i = samePartsLength; i < fromParts.length; i++) {\n                outputParts.push(\"..\");\n            } outputParts = outputParts.concat(toParts.slice(samePartsLength)); return outputParts.join(\"/\"); } };\n        var UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n        var UTF8ArrayToString = function (heapOrArray, idx, maxBytesToRead) { var endIdx = idx + maxBytesToRead; var endPtr = idx; while (heapOrArray[endPtr] && !(endPtr >= endIdx))\n            ++endPtr; if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n            return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n        } var str = \"\"; while (idx < endPtr) {\n            var u0 = heapOrArray[idx++];\n            if (!(u0 & 128)) {\n                str += String.fromCharCode(u0);\n                continue;\n            }\n            var u1 = heapOrArray[idx++] & 63;\n            if ((u0 & 224) == 192) {\n                str += String.fromCharCode((u0 & 31) << 6 | u1);\n                continue;\n            }\n            var u2 = heapOrArray[idx++] & 63;\n            if ((u0 & 240) == 224) {\n                u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            }\n            else {\n                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n            }\n            if (u0 < 65536) {\n                str += String.fromCharCode(u0);\n            }\n            else {\n                var ch = u0 - 65536;\n                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n            }\n        } return str; };\n        var FS_stdin_getChar_buffer = [];\n        var lengthBytesUTF8 = function (str) { var len = 0; for (var i = 0; i < str.length; ++i) {\n            var c = str.charCodeAt(i);\n            if (c <= 127) {\n                len++;\n            }\n            else if (c <= 2047) {\n                len += 2;\n            }\n            else if (c >= 55296 && c <= 57343) {\n                len += 4;\n                ++i;\n            }\n            else {\n                len += 3;\n            }\n        } return len; };\n        var stringToUTF8Array = function (str, heap, outIdx, maxBytesToWrite) { if (!(maxBytesToWrite > 0))\n            return 0; var startIdx = outIdx; var endIdx = outIdx + maxBytesToWrite - 1; for (var i = 0; i < str.length; ++i) {\n            var u = str.charCodeAt(i);\n            if (u >= 55296 && u <= 57343) {\n                var u1 = str.charCodeAt(++i);\n                u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n            }\n            if (u <= 127) {\n                if (outIdx >= endIdx)\n                    break;\n                heap[outIdx++] = u;\n            }\n            else if (u <= 2047) {\n                if (outIdx + 1 >= endIdx)\n                    break;\n                heap[outIdx++] = 192 | u >> 6;\n                heap[outIdx++] = 128 | u & 63;\n            }\n            else if (u <= 65535) {\n                if (outIdx + 2 >= endIdx)\n                    break;\n                heap[outIdx++] = 224 | u >> 12;\n                heap[outIdx++] = 128 | u >> 6 & 63;\n                heap[outIdx++] = 128 | u & 63;\n            }\n            else {\n                if (outIdx + 3 >= endIdx)\n                    break;\n                heap[outIdx++] = 240 | u >> 18;\n                heap[outIdx++] = 128 | u >> 12 & 63;\n                heap[outIdx++] = 128 | u >> 6 & 63;\n                heap[outIdx++] = 128 | u & 63;\n            }\n        } heap[outIdx] = 0; return outIdx - startIdx; };\n        function intArrayFromString(stringy, dontAddNull, length) { var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1; var u8array = new Array(len); var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length); if (dontAddNull)\n            u8array.length = numBytesWritten; return u8array; }\n        var FS_stdin_getChar = function () { if (!FS_stdin_getChar_buffer.length) {\n            var result = null;\n            if (ENVIRONMENT_IS_NODE) {\n                var BUFSIZE = 256;\n                var buf = Buffer.alloc(BUFSIZE);\n                var bytesRead = 0;\n                var fd = process.stdin.fd;\n                try {\n                    bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, -1);\n                }\n                catch (e) {\n                    if (e.toString().includes(\"EOF\"))\n                        bytesRead = 0;\n                    else\n                        throw e;\n                }\n                if (bytesRead > 0) {\n                    result = buf.slice(0, bytesRead).toString(\"utf-8\");\n                }\n                else {\n                    result = null;\n                }\n            }\n            else if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\n                result = window.prompt(\"Input: \");\n                if (result !== null) {\n                    result += \"\\n\";\n                }\n            }\n            else if (typeof readline == \"function\") {\n                result = readline();\n                if (result !== null) {\n                    result += \"\\n\";\n                }\n            }\n            if (!result) {\n                return null;\n            }\n            FS_stdin_getChar_buffer = intArrayFromString(result, true);\n        } return FS_stdin_getChar_buffer.shift(); };\n        var TTY = { ttys: [], init: function () { }, shutdown: function () { }, register: function (dev, ops) { TTY.ttys[dev] = { input: [], output: [], ops: ops }; FS.registerDevice(dev, TTY.stream_ops); }, stream_ops: { open: function (stream) { var tty = TTY.ttys[stream.node.rdev]; if (!tty) {\n                    throw new FS.ErrnoError(43);\n                } stream.tty = tty; stream.seekable = false; }, close: function (stream) { stream.tty.ops.fsync(stream.tty); }, fsync: function (stream) { stream.tty.ops.fsync(stream.tty); }, read: function (stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.get_char) {\n                    throw new FS.ErrnoError(60);\n                } var bytesRead = 0; for (var i = 0; i < length; i++) {\n                    var result;\n                    try {\n                        result = stream.tty.ops.get_char(stream.tty);\n                    }\n                    catch (e) {\n                        throw new FS.ErrnoError(29);\n                    }\n                    if (result === undefined && bytesRead === 0) {\n                        throw new FS.ErrnoError(6);\n                    }\n                    if (result === null || result === undefined)\n                        break;\n                    bytesRead++;\n                    buffer[offset + i] = result;\n                } if (bytesRead) {\n                    stream.node.timestamp = Date.now();\n                } return bytesRead; }, write: function (stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.put_char) {\n                    throw new FS.ErrnoError(60);\n                } try {\n                    for (var i = 0; i < length; i++) {\n                        stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n                    }\n                }\n                catch (e) {\n                    throw new FS.ErrnoError(29);\n                } if (length) {\n                    stream.node.timestamp = Date.now();\n                } return i; } }, default_tty_ops: { get_char: function (tty) { return FS_stdin_getChar(); }, put_char: function (tty, val) { if (val === null || val === 10) {\n                    out(UTF8ArrayToString(tty.output, 0));\n                    tty.output = [];\n                }\n                else {\n                    if (val != 0)\n                        tty.output.push(val);\n                } }, fsync: function (tty) { if (tty.output && tty.output.length > 0) {\n                    out(UTF8ArrayToString(tty.output, 0));\n                    tty.output = [];\n                } }, ioctl_tcgets: function (tty) { return { c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }; }, ioctl_tcsets: function (tty, optional_actions, data) { return 0; }, ioctl_tiocgwinsz: function (tty) { return [24, 80]; } }, default_tty1_ops: { put_char: function (tty, val) { if (val === null || val === 10) {\n                    err(UTF8ArrayToString(tty.output, 0));\n                    tty.output = [];\n                }\n                else {\n                    if (val != 0)\n                        tty.output.push(val);\n                } }, fsync: function (tty) { if (tty.output && tty.output.length > 0) {\n                    err(UTF8ArrayToString(tty.output, 0));\n                    tty.output = [];\n                } } } };\n        var mmapAlloc = function (size) { abort(); };\n        var MEMFS = { ops_table: null, mount: function (mount) { return MEMFS.createNode(null, \"/\", 16384 | 511, 0); }, createNode: function (parent, name, mode, dev) { if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n                throw new FS.ErrnoError(63);\n            } if (!MEMFS.ops_table) {\n                MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };\n            } var node = FS.createNode(parent, name, mode, dev); if (FS.isDir(node.mode)) {\n                node.node_ops = MEMFS.ops_table.dir.node;\n                node.stream_ops = MEMFS.ops_table.dir.stream;\n                node.contents = {};\n            }\n            else if (FS.isFile(node.mode)) {\n                node.node_ops = MEMFS.ops_table.file.node;\n                node.stream_ops = MEMFS.ops_table.file.stream;\n                node.usedBytes = 0;\n                node.contents = null;\n            }\n            else if (FS.isLink(node.mode)) {\n                node.node_ops = MEMFS.ops_table.link.node;\n                node.stream_ops = MEMFS.ops_table.link.stream;\n            }\n            else if (FS.isChrdev(node.mode)) {\n                node.node_ops = MEMFS.ops_table.chrdev.node;\n                node.stream_ops = MEMFS.ops_table.chrdev.stream;\n            } node.timestamp = Date.now(); if (parent) {\n                parent.contents[name] = node;\n                parent.timestamp = node.timestamp;\n            } return node; }, getFileDataAsTypedArray: function (node) { if (!node.contents)\n                return new Uint8Array(0); if (node.contents.subarray)\n                return node.contents.subarray(0, node.usedBytes); return new Uint8Array(node.contents); }, expandFileStorage: function (node, newCapacity) { var prevCapacity = node.contents ? node.contents.length : 0; if (prevCapacity >= newCapacity)\n                return; var CAPACITY_DOUBLING_MAX = 1024 * 1024; newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0); if (prevCapacity != 0)\n                newCapacity = Math.max(newCapacity, 256); var oldContents = node.contents; node.contents = new Uint8Array(newCapacity); if (node.usedBytes > 0)\n                node.contents.set(oldContents.subarray(0, node.usedBytes), 0); }, resizeFileStorage: function (node, newSize) { if (node.usedBytes == newSize)\n                return; if (newSize == 0) {\n                node.contents = null;\n                node.usedBytes = 0;\n            }\n            else {\n                var oldContents = node.contents;\n                node.contents = new Uint8Array(newSize);\n                if (oldContents) {\n                    node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n                }\n                node.usedBytes = newSize;\n            } }, node_ops: { getattr: function (node) { var attr = {}; attr.dev = FS.isChrdev(node.mode) ? node.id : 1; attr.ino = node.id; attr.mode = node.mode; attr.nlink = 1; attr.uid = 0; attr.gid = 0; attr.rdev = node.rdev; if (FS.isDir(node.mode)) {\n                    attr.size = 4096;\n                }\n                else if (FS.isFile(node.mode)) {\n                    attr.size = node.usedBytes;\n                }\n                else if (FS.isLink(node.mode)) {\n                    attr.size = node.link.length;\n                }\n                else {\n                    attr.size = 0;\n                } attr.atime = new Date(node.timestamp); attr.mtime = new Date(node.timestamp); attr.ctime = new Date(node.timestamp); attr.blksize = 4096; attr.blocks = Math.ceil(attr.size / attr.blksize); return attr; }, setattr: function (node, attr) { if (attr.mode !== undefined) {\n                    node.mode = attr.mode;\n                } if (attr.timestamp !== undefined) {\n                    node.timestamp = attr.timestamp;\n                } if (attr.size !== undefined) {\n                    MEMFS.resizeFileStorage(node, attr.size);\n                } }, lookup: function (parent, name) { throw FS.genericErrors[44]; }, mknod: function (parent, name, mode, dev) { return MEMFS.createNode(parent, name, mode, dev); }, rename: function (old_node, new_dir, new_name) { if (FS.isDir(old_node.mode)) {\n                    var new_node;\n                    try {\n                        new_node = FS.lookupNode(new_dir, new_name);\n                    }\n                    catch (e) { }\n                    if (new_node) {\n                        for (var i in new_node.contents) {\n                            throw new FS.ErrnoError(55);\n                        }\n                    }\n                } delete old_node.parent.contents[old_node.name]; old_node.parent.timestamp = Date.now(); old_node.name = new_name; new_dir.contents[new_name] = old_node; new_dir.timestamp = old_node.parent.timestamp; old_node.parent = new_dir; }, unlink: function (parent, name) { delete parent.contents[name]; parent.timestamp = Date.now(); }, rmdir: function (parent, name) { var node = FS.lookupNode(parent, name); for (var i in node.contents) {\n                    throw new FS.ErrnoError(55);\n                } delete parent.contents[name]; parent.timestamp = Date.now(); }, readdir: function (node) { var entries = [\".\", \"..\"]; for (var key in node.contents) {\n                    if (!node.contents.hasOwnProperty(key)) {\n                        continue;\n                    }\n                    entries.push(key);\n                } return entries; }, symlink: function (parent, newname, oldpath) { var node = MEMFS.createNode(parent, newname, 511 | 40960, 0); node.link = oldpath; return node; }, readlink: function (node) { if (!FS.isLink(node.mode)) {\n                    throw new FS.ErrnoError(28);\n                } return node.link; } }, stream_ops: { read: function (stream, buffer, offset, length, position) { var contents = stream.node.contents; if (position >= stream.node.usedBytes)\n                    return 0; var size = Math.min(stream.node.usedBytes - position, length); if (size > 8 && contents.subarray) {\n                    buffer.set(contents.subarray(position, position + size), offset);\n                }\n                else {\n                    for (var i = 0; i < size; i++)\n                        buffer[offset + i] = contents[position + i];\n                } return size; }, write: function (stream, buffer, offset, length, position, canOwn) { if (buffer.buffer === HEAP8.buffer) {\n                    canOwn = false;\n                } if (!length)\n                    return 0; var node = stream.node; node.timestamp = Date.now(); if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n                    if (canOwn) {\n                        node.contents = buffer.subarray(offset, offset + length);\n                        node.usedBytes = length;\n                        return length;\n                    }\n                    else if (node.usedBytes === 0 && position === 0) {\n                        node.contents = buffer.slice(offset, offset + length);\n                        node.usedBytes = length;\n                        return length;\n                    }\n                    else if (position + length <= node.usedBytes) {\n                        node.contents.set(buffer.subarray(offset, offset + length), position);\n                        return length;\n                    }\n                } MEMFS.expandFileStorage(node, position + length); if (node.contents.subarray && buffer.subarray) {\n                    node.contents.set(buffer.subarray(offset, offset + length), position);\n                }\n                else {\n                    for (var i = 0; i < length; i++) {\n                        node.contents[position + i] = buffer[offset + i];\n                    }\n                } node.usedBytes = Math.max(node.usedBytes, position + length); return length; }, llseek: function (stream, offset, whence) { var position = offset; if (whence === 1) {\n                    position += stream.position;\n                }\n                else if (whence === 2) {\n                    if (FS.isFile(stream.node.mode)) {\n                        position += stream.node.usedBytes;\n                    }\n                } if (position < 0) {\n                    throw new FS.ErrnoError(28);\n                } return position; }, allocate: function (stream, offset, length) { MEMFS.expandFileStorage(stream.node, offset + length); stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length); }, mmap: function (stream, length, position, prot, flags) { if (!FS.isFile(stream.node.mode)) {\n                    throw new FS.ErrnoError(43);\n                } var ptr; var allocated; var contents = stream.node.contents; if (!(flags & 2) && contents.buffer === HEAP8.buffer) {\n                    allocated = false;\n                    ptr = contents.byteOffset;\n                }\n                else {\n                    if (position > 0 || position + length < contents.length) {\n                        if (contents.subarray) {\n                            contents = contents.subarray(position, position + length);\n                        }\n                        else {\n                            contents = Array.prototype.slice.call(contents, position, position + length);\n                        }\n                    }\n                    allocated = true;\n                    ptr = mmapAlloc(length);\n                    if (!ptr) {\n                        throw new FS.ErrnoError(48);\n                    }\n                    HEAP8.set(contents, ptr);\n                } return { ptr: ptr, allocated: allocated }; }, msync: function (stream, buffer, offset, length, mmapFlags) { MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false); return 0; } } };\n        var asyncLoad = function (url, onload, onerror, noRunDep) { var dep = !noRunDep ? getUniqueRunDependency(\"al \".concat(url)) : \"\"; readAsync(url, (function (arrayBuffer) { assert(arrayBuffer, \"Loading data file \\\"\".concat(url, \"\\\" failed (no arrayBuffer).\")); onload(new Uint8Array(arrayBuffer)); if (dep)\n            removeRunDependency(dep); }), (function (event) { if (onerror) {\n            onerror();\n        }\n        else {\n            throw \"Loading data file \\\"\".concat(url, \"\\\" failed.\");\n        } })); if (dep)\n            addRunDependency(dep); };\n        var preloadPlugins = Module[\"preloadPlugins\"] || [];\n        function FS_handledByPreloadPlugin(byteArray, fullname, finish, onerror) { if (typeof Browser != \"undefined\")\n            Browser.init(); var handled = false; preloadPlugins.forEach((function (plugin) { if (handled)\n            return; if (plugin[\"canHandle\"](fullname)) {\n            plugin[\"handle\"](byteArray, fullname, finish, onerror);\n            handled = true;\n        } })); return handled; }\n        function FS_createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) { var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent; var dep = getUniqueRunDependency(\"cp \".concat(fullname)); function processData(byteArray) { function finish(byteArray) { if (preFinish)\n            preFinish(); if (!dontCreateFile) {\n            FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n        } if (onload)\n            onload(); removeRunDependency(dep); } if (FS_handledByPreloadPlugin(byteArray, fullname, finish, (function () { if (onerror)\n            onerror(); removeRunDependency(dep); }))) {\n            return;\n        } finish(byteArray); } addRunDependency(dep); if (typeof url == \"string\") {\n            asyncLoad(url, (function (byteArray) { return processData(byteArray); }), onerror);\n        }\n        else {\n            processData(url);\n        } }\n        function FS_modeStringToFlags(str) { var flagModes = { \"r\": 0, \"r+\": 2, \"w\": 512 | 64 | 1, \"w+\": 512 | 64 | 2, \"a\": 1024 | 64 | 1, \"a+\": 1024 | 64 | 2 }; var flags = flagModes[str]; if (typeof flags == \"undefined\") {\n            throw new Error(\"Unknown file open mode: \".concat(str));\n        } return flags; }\n        function FS_getMode(canRead, canWrite) { var mode = 0; if (canRead)\n            mode |= 292 | 73; if (canWrite)\n            mode |= 146; return mode; }\n        var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: \"/\", initialized: false, ignorePermissions: true, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function (path, opts) {\n                if (opts === void 0) { opts = {}; }\n                path = PATH_FS.resolve(path);\n                if (!path)\n                    return { path: \"\", node: null };\n                var defaults = { follow_mount: true, recurse_count: 0 };\n                opts = Object.assign(defaults, opts);\n                if (opts.recurse_count > 8) {\n                    throw new FS.ErrnoError(32);\n                }\n                var parts = path.split(\"/\").filter((function (p) { return !!p; }));\n                var current = FS.root;\n                var current_path = \"/\";\n                for (var i = 0; i < parts.length; i++) {\n                    var islast = i === parts.length - 1;\n                    if (islast && opts.parent) {\n                        break;\n                    }\n                    current = FS.lookupNode(current, parts[i]);\n                    current_path = PATH.join2(current_path, parts[i]);\n                    if (FS.isMountpoint(current)) {\n                        if (!islast || islast && opts.follow_mount) {\n                            current = current.mounted.root;\n                        }\n                    }\n                    if (!islast || opts.follow) {\n                        var count = 0;\n                        while (FS.isLink(current.mode)) {\n                            var link = FS.readlink(current_path);\n                            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n                            var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });\n                            current = lookup.node;\n                            if (count++ > 40) {\n                                throw new FS.ErrnoError(32);\n                            }\n                        }\n                    }\n                }\n                return { path: current_path, node: current };\n            }, getPath: function (node) { var path; while (true) {\n                if (FS.isRoot(node)) {\n                    var mount = node.mount.mountpoint;\n                    if (!path)\n                        return mount;\n                    return mount[mount.length - 1] !== \"/\" ? \"\".concat(mount, \"/\").concat(path) : mount + path;\n                }\n                path = path ? \"\".concat(node.name, \"/\").concat(path) : node.name;\n                node = node.parent;\n            } }, hashName: function (parentid, name) { var hash = 0; for (var i = 0; i < name.length; i++) {\n                hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n            } return (parentid + hash >>> 0) % FS.nameTable.length; }, hashAddNode: function (node) { var hash = FS.hashName(node.parent.id, node.name); node.name_next = FS.nameTable[hash]; FS.nameTable[hash] = node; }, hashRemoveNode: function (node) { var hash = FS.hashName(node.parent.id, node.name); if (FS.nameTable[hash] === node) {\n                FS.nameTable[hash] = node.name_next;\n            }\n            else {\n                var current = FS.nameTable[hash];\n                while (current) {\n                    if (current.name_next === node) {\n                        current.name_next = node.name_next;\n                        break;\n                    }\n                    current = current.name_next;\n                }\n            } }, lookupNode: function (parent, name) { var errCode = FS.mayLookup(parent); if (errCode) {\n                throw new FS.ErrnoError(errCode, parent);\n            } var hash = FS.hashName(parent.id, name); for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n                var nodeName = node.name;\n                if (node.parent.id === parent.id && nodeName === name) {\n                    return node;\n                }\n            } return FS.lookup(parent, name); }, createNode: function (parent, name, mode, rdev) { var node = new FS.FSNode(parent, name, mode, rdev); FS.hashAddNode(node); return node; }, destroyNode: function (node) { FS.hashRemoveNode(node); }, isRoot: function (node) { return node === node.parent; }, isMountpoint: function (node) { return !!node.mounted; }, isFile: function (mode) { return (mode & 61440) === 32768; }, isDir: function (mode) { return (mode & 61440) === 16384; }, isLink: function (mode) { return (mode & 61440) === 40960; }, isChrdev: function (mode) { return (mode & 61440) === 8192; }, isBlkdev: function (mode) { return (mode & 61440) === 24576; }, isFIFO: function (mode) { return (mode & 61440) === 4096; }, isSocket: function (mode) { return (mode & 49152) === 49152; }, flagsToPermissionString: function (flag) { var perms = [\"r\", \"w\", \"rw\"][flag & 3]; if (flag & 512) {\n                perms += \"w\";\n            } return perms; }, nodePermissions: function (node, perms) { if (FS.ignorePermissions) {\n                return 0;\n            } if (perms.includes(\"r\") && !(node.mode & 292)) {\n                return 2;\n            }\n            else if (perms.includes(\"w\") && !(node.mode & 146)) {\n                return 2;\n            }\n            else if (perms.includes(\"x\") && !(node.mode & 73)) {\n                return 2;\n            } return 0; }, mayLookup: function (dir) { var errCode = FS.nodePermissions(dir, \"x\"); if (errCode)\n                return errCode; if (!dir.node_ops.lookup)\n                return 2; return 0; }, mayCreate: function (dir, name) { try {\n                var node = FS.lookupNode(dir, name);\n                return 20;\n            }\n            catch (e) { } return FS.nodePermissions(dir, \"wx\"); }, mayDelete: function (dir, name, isdir) { var node; try {\n                node = FS.lookupNode(dir, name);\n            }\n            catch (e) {\n                return e.errno;\n            } var errCode = FS.nodePermissions(dir, \"wx\"); if (errCode) {\n                return errCode;\n            } if (isdir) {\n                if (!FS.isDir(node.mode)) {\n                    return 54;\n                }\n                if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n                    return 10;\n                }\n            }\n            else {\n                if (FS.isDir(node.mode)) {\n                    return 31;\n                }\n            } return 0; }, mayOpen: function (node, flags) { if (!node) {\n                return 44;\n            } if (FS.isLink(node.mode)) {\n                return 32;\n            }\n            else if (FS.isDir(node.mode)) {\n                if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\n                    return 31;\n                }\n            } return FS.nodePermissions(node, FS.flagsToPermissionString(flags)); }, MAX_OPEN_FDS: 4096, nextfd: function () { for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\n                if (!FS.streams[fd]) {\n                    return fd;\n                }\n            } throw new FS.ErrnoError(33); }, getStreamChecked: function (fd) { var stream = FS.getStream(fd); if (!stream) {\n                throw new FS.ErrnoError(8);\n            } return stream; }, getStream: function (fd) { return FS.streams[fd]; }, createStream: function (stream, fd) {\n                if (fd === void 0) { fd = -1; }\n                if (!FS.FSStream) {\n                    FS.FSStream = function () { this.shared = {}; };\n                    FS.FSStream.prototype = {};\n                    Object.defineProperties(FS.FSStream.prototype, { object: { get: function () { return this.node; }, set: function (val) { this.node = val; } }, isRead: { get: function () { return (this.flags & 2097155) !== 1; } }, isWrite: { get: function () { return (this.flags & 2097155) !== 0; } }, isAppend: { get: function () { return this.flags & 1024; } }, flags: { get: function () { return this.shared.flags; }, set: function (val) { this.shared.flags = val; } }, position: { get: function () { return this.shared.position; }, set: function (val) { this.shared.position = val; } } });\n                }\n                stream = Object.assign(new FS.FSStream, stream);\n                if (fd == -1) {\n                    fd = FS.nextfd();\n                }\n                stream.fd = fd;\n                FS.streams[fd] = stream;\n                return stream;\n            }, closeStream: function (fd) { FS.streams[fd] = null; }, chrdev_stream_ops: { open: function (stream) { var device = FS.getDevice(stream.node.rdev); stream.stream_ops = device.stream_ops; if (stream.stream_ops.open) {\n                    stream.stream_ops.open(stream);\n                } }, llseek: function () { throw new FS.ErrnoError(70); } }, major: function (dev) { return dev >> 8; }, minor: function (dev) { return dev & 255; }, makedev: function (ma, mi) { return ma << 8 | mi; }, registerDevice: function (dev, ops) { FS.devices[dev] = { stream_ops: ops }; }, getDevice: function (dev) { return FS.devices[dev]; }, getMounts: function (mount) { var mounts = []; var check = [mount]; while (check.length) {\n                var m = check.pop();\n                mounts.push(m);\n                check.push.apply(check, m.mounts);\n            } return mounts; }, syncfs: function (populate, callback) { if (typeof populate == \"function\") {\n                callback = populate;\n                populate = false;\n            } FS.syncFSRequests++; if (FS.syncFSRequests > 1) {\n                err(\"warning: \".concat(FS.syncFSRequests, \" FS.syncfs operations in flight at once, probably just doing extra work\"));\n            } var mounts = FS.getMounts(FS.root.mount); var completed = 0; function doCallback(errCode) { FS.syncFSRequests--; return callback(errCode); } function done(errCode) { if (errCode) {\n                if (!done.errored) {\n                    done.errored = true;\n                    return doCallback(errCode);\n                }\n                return;\n            } if (++completed >= mounts.length) {\n                doCallback(null);\n            } } mounts.forEach((function (mount) { if (!mount.type.syncfs) {\n                return done(null);\n            } mount.type.syncfs(mount, populate, done); })); }, mount: function (type, opts, mountpoint) { var root = mountpoint === \"/\"; var pseudo = !mountpoint; var node; if (root && FS.root) {\n                throw new FS.ErrnoError(10);\n            }\n            else if (!root && !pseudo) {\n                var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n                mountpoint = lookup.path;\n                node = lookup.node;\n                if (FS.isMountpoint(node)) {\n                    throw new FS.ErrnoError(10);\n                }\n                if (!FS.isDir(node.mode)) {\n                    throw new FS.ErrnoError(54);\n                }\n            } var mount = { type: type, opts: opts, mountpoint: mountpoint, mounts: [] }; var mountRoot = type.mount(mount); mountRoot.mount = mount; mount.root = mountRoot; if (root) {\n                FS.root = mountRoot;\n            }\n            else if (node) {\n                node.mounted = mount;\n                if (node.mount) {\n                    node.mount.mounts.push(mount);\n                }\n            } return mountRoot; }, unmount: function (mountpoint) { var lookup = FS.lookupPath(mountpoint, { follow_mount: false }); if (!FS.isMountpoint(lookup.node)) {\n                throw new FS.ErrnoError(28);\n            } var node = lookup.node; var mount = node.mounted; var mounts = FS.getMounts(mount); Object.keys(FS.nameTable).forEach((function (hash) { var current = FS.nameTable[hash]; while (current) {\n                var next = current.name_next;\n                if (mounts.includes(current.mount)) {\n                    FS.destroyNode(current);\n                }\n                current = next;\n            } })); node.mounted = null; var idx = node.mount.mounts.indexOf(mount); node.mount.mounts.splice(idx, 1); }, lookup: function (parent, name) { return parent.node_ops.lookup(parent, name); }, mknod: function (path, mode, dev) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); if (!name || name === \".\" || name === \"..\") {\n                throw new FS.ErrnoError(28);\n            } var errCode = FS.mayCreate(parent, name); if (errCode) {\n                throw new FS.ErrnoError(errCode);\n            } if (!parent.node_ops.mknod) {\n                throw new FS.ErrnoError(63);\n            } return parent.node_ops.mknod(parent, name, mode, dev); }, create: function (path, mode) { mode = mode !== undefined ? mode : 438; mode &= 4095; mode |= 32768; return FS.mknod(path, mode, 0); }, mkdir: function (path, mode) { mode = mode !== undefined ? mode : 511; mode &= 511 | 512; mode |= 16384; return FS.mknod(path, mode, 0); }, mkdirTree: function (path, mode) { var dirs = path.split(\"/\"); var d = \"\"; for (var i = 0; i < dirs.length; ++i) {\n                if (!dirs[i])\n                    continue;\n                d += \"/\" + dirs[i];\n                try {\n                    FS.mkdir(d, mode);\n                }\n                catch (e) {\n                    if (e.errno != 20)\n                        throw e;\n                }\n            } }, mkdev: function (path, mode, dev) { if (typeof dev == \"undefined\") {\n                dev = mode;\n                mode = 438;\n            } mode |= 8192; return FS.mknod(path, mode, dev); }, symlink: function (oldpath, newpath) { if (!PATH_FS.resolve(oldpath)) {\n                throw new FS.ErrnoError(44);\n            } var lookup = FS.lookupPath(newpath, { parent: true }); var parent = lookup.node; if (!parent) {\n                throw new FS.ErrnoError(44);\n            } var newname = PATH.basename(newpath); var errCode = FS.mayCreate(parent, newname); if (errCode) {\n                throw new FS.ErrnoError(errCode);\n            } if (!parent.node_ops.symlink) {\n                throw new FS.ErrnoError(63);\n            } return parent.node_ops.symlink(parent, newname, oldpath); }, rename: function (old_path, new_path) { var old_dirname = PATH.dirname(old_path); var new_dirname = PATH.dirname(new_path); var old_name = PATH.basename(old_path); var new_name = PATH.basename(new_path); var lookup, old_dir, new_dir; lookup = FS.lookupPath(old_path, { parent: true }); old_dir = lookup.node; lookup = FS.lookupPath(new_path, { parent: true }); new_dir = lookup.node; if (!old_dir || !new_dir)\n                throw new FS.ErrnoError(44); if (old_dir.mount !== new_dir.mount) {\n                throw new FS.ErrnoError(75);\n            } var old_node = FS.lookupNode(old_dir, old_name); var relative = PATH_FS.relative(old_path, new_dirname); if (relative.charAt(0) !== \".\") {\n                throw new FS.ErrnoError(28);\n            } relative = PATH_FS.relative(new_path, old_dirname); if (relative.charAt(0) !== \".\") {\n                throw new FS.ErrnoError(55);\n            } var new_node; try {\n                new_node = FS.lookupNode(new_dir, new_name);\n            }\n            catch (e) { } if (old_node === new_node) {\n                return;\n            } var isdir = FS.isDir(old_node.mode); var errCode = FS.mayDelete(old_dir, old_name, isdir); if (errCode) {\n                throw new FS.ErrnoError(errCode);\n            } errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name); if (errCode) {\n                throw new FS.ErrnoError(errCode);\n            } if (!old_dir.node_ops.rename) {\n                throw new FS.ErrnoError(63);\n            } if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n                throw new FS.ErrnoError(10);\n            } if (new_dir !== old_dir) {\n                errCode = FS.nodePermissions(old_dir, \"w\");\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n            } FS.hashRemoveNode(old_node); try {\n                old_dir.node_ops.rename(old_node, new_dir, new_name);\n            }\n            catch (e) {\n                throw e;\n            }\n            finally {\n                FS.hashAddNode(old_node);\n            } }, rmdir: function (path) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); var node = FS.lookupNode(parent, name); var errCode = FS.mayDelete(parent, name, true); if (errCode) {\n                throw new FS.ErrnoError(errCode);\n            } if (!parent.node_ops.rmdir) {\n                throw new FS.ErrnoError(63);\n            } if (FS.isMountpoint(node)) {\n                throw new FS.ErrnoError(10);\n            } parent.node_ops.rmdir(parent, name); FS.destroyNode(node); }, readdir: function (path) { var lookup = FS.lookupPath(path, { follow: true }); var node = lookup.node; if (!node.node_ops.readdir) {\n                throw new FS.ErrnoError(54);\n            } return node.node_ops.readdir(node); }, unlink: function (path) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; if (!parent) {\n                throw new FS.ErrnoError(44);\n            } var name = PATH.basename(path); var node = FS.lookupNode(parent, name); var errCode = FS.mayDelete(parent, name, false); if (errCode) {\n                throw new FS.ErrnoError(errCode);\n            } if (!parent.node_ops.unlink) {\n                throw new FS.ErrnoError(63);\n            } if (FS.isMountpoint(node)) {\n                throw new FS.ErrnoError(10);\n            } parent.node_ops.unlink(parent, name); FS.destroyNode(node); }, readlink: function (path) { var lookup = FS.lookupPath(path); var link = lookup.node; if (!link) {\n                throw new FS.ErrnoError(44);\n            } if (!link.node_ops.readlink) {\n                throw new FS.ErrnoError(28);\n            } return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link)); }, stat: function (path, dontFollow) { var lookup = FS.lookupPath(path, { follow: !dontFollow }); var node = lookup.node; if (!node) {\n                throw new FS.ErrnoError(44);\n            } if (!node.node_ops.getattr) {\n                throw new FS.ErrnoError(63);\n            } return node.node_ops.getattr(node); }, lstat: function (path) { return FS.stat(path, true); }, chmod: function (path, mode, dontFollow) { var node; if (typeof path == \"string\") {\n                var lookup = FS.lookupPath(path, { follow: !dontFollow });\n                node = lookup.node;\n            }\n            else {\n                node = path;\n            } if (!node.node_ops.setattr) {\n                throw new FS.ErrnoError(63);\n            } node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() }); }, lchmod: function (path, mode) { FS.chmod(path, mode, true); }, fchmod: function (fd, mode) { var stream = FS.getStreamChecked(fd); FS.chmod(stream.node, mode); }, chown: function (path, uid, gid, dontFollow) { var node; if (typeof path == \"string\") {\n                var lookup = FS.lookupPath(path, { follow: !dontFollow });\n                node = lookup.node;\n            }\n            else {\n                node = path;\n            } if (!node.node_ops.setattr) {\n                throw new FS.ErrnoError(63);\n            } node.node_ops.setattr(node, { timestamp: Date.now() }); }, lchown: function (path, uid, gid) { FS.chown(path, uid, gid, true); }, fchown: function (fd, uid, gid) { var stream = FS.getStreamChecked(fd); FS.chown(stream.node, uid, gid); }, truncate: function (path, len) { if (len < 0) {\n                throw new FS.ErrnoError(28);\n            } var node; if (typeof path == \"string\") {\n                var lookup = FS.lookupPath(path, { follow: true });\n                node = lookup.node;\n            }\n            else {\n                node = path;\n            } if (!node.node_ops.setattr) {\n                throw new FS.ErrnoError(63);\n            } if (FS.isDir(node.mode)) {\n                throw new FS.ErrnoError(31);\n            } if (!FS.isFile(node.mode)) {\n                throw new FS.ErrnoError(28);\n            } var errCode = FS.nodePermissions(node, \"w\"); if (errCode) {\n                throw new FS.ErrnoError(errCode);\n            } node.node_ops.setattr(node, { size: len, timestamp: Date.now() }); }, ftruncate: function (fd, len) { var stream = FS.getStreamChecked(fd); if ((stream.flags & 2097155) === 0) {\n                throw new FS.ErrnoError(28);\n            } FS.truncate(stream.node, len); }, utime: function (path, atime, mtime) { var lookup = FS.lookupPath(path, { follow: true }); var node = lookup.node; node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) }); }, open: function (path, flags, mode) { if (path === \"\") {\n                throw new FS.ErrnoError(44);\n            } flags = typeof flags == \"string\" ? FS_modeStringToFlags(flags) : flags; mode = typeof mode == \"undefined\" ? 438 : mode; if (flags & 64) {\n                mode = mode & 4095 | 32768;\n            }\n            else {\n                mode = 0;\n            } var node; if (typeof path == \"object\") {\n                node = path;\n            }\n            else {\n                path = PATH.normalize(path);\n                try {\n                    var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });\n                    node = lookup.node;\n                }\n                catch (e) { }\n            } var created = false; if (flags & 64) {\n                if (node) {\n                    if (flags & 128) {\n                        throw new FS.ErrnoError(20);\n                    }\n                }\n                else {\n                    node = FS.mknod(path, mode, 0);\n                    created = true;\n                }\n            } if (!node) {\n                throw new FS.ErrnoError(44);\n            } if (FS.isChrdev(node.mode)) {\n                flags &= ~512;\n            } if (flags & 65536 && !FS.isDir(node.mode)) {\n                throw new FS.ErrnoError(54);\n            } if (!created) {\n                var errCode = FS.mayOpen(node, flags);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n            } if (flags & 512 && !created) {\n                FS.truncate(node, 0);\n            } flags &= ~(128 | 512 | 131072); var stream = FS.createStream({ node: node, path: FS.getPath(node), flags: flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }); if (stream.stream_ops.open) {\n                stream.stream_ops.open(stream);\n            } if (Module[\"logReadFiles\"] && !(flags & 1)) {\n                if (!FS.readFiles)\n                    FS.readFiles = {};\n                if (!(path in FS.readFiles)) {\n                    FS.readFiles[path] = 1;\n                }\n            } return stream; }, close: function (stream) { if (FS.isClosed(stream)) {\n                throw new FS.ErrnoError(8);\n            } if (stream.getdents)\n                stream.getdents = null; try {\n                if (stream.stream_ops.close) {\n                    stream.stream_ops.close(stream);\n                }\n            }\n            catch (e) {\n                throw e;\n            }\n            finally {\n                FS.closeStream(stream.fd);\n            } stream.fd = null; }, isClosed: function (stream) { return stream.fd === null; }, llseek: function (stream, offset, whence) { if (FS.isClosed(stream)) {\n                throw new FS.ErrnoError(8);\n            } if (!stream.seekable || !stream.stream_ops.llseek) {\n                throw new FS.ErrnoError(70);\n            } if (whence != 0 && whence != 1 && whence != 2) {\n                throw new FS.ErrnoError(28);\n            } stream.position = stream.stream_ops.llseek(stream, offset, whence); stream.ungotten = []; return stream.position; }, read: function (stream, buffer, offset, length, position) { if (length < 0 || position < 0) {\n                throw new FS.ErrnoError(28);\n            } if (FS.isClosed(stream)) {\n                throw new FS.ErrnoError(8);\n            } if ((stream.flags & 2097155) === 1) {\n                throw new FS.ErrnoError(8);\n            } if (FS.isDir(stream.node.mode)) {\n                throw new FS.ErrnoError(31);\n            } if (!stream.stream_ops.read) {\n                throw new FS.ErrnoError(28);\n            } var seeking = typeof position != \"undefined\"; if (!seeking) {\n                position = stream.position;\n            }\n            else if (!stream.seekable) {\n                throw new FS.ErrnoError(70);\n            } var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position); if (!seeking)\n                stream.position += bytesRead; return bytesRead; }, write: function (stream, buffer, offset, length, position, canOwn) { if (length < 0 || position < 0) {\n                throw new FS.ErrnoError(28);\n            } if (FS.isClosed(stream)) {\n                throw new FS.ErrnoError(8);\n            } if ((stream.flags & 2097155) === 0) {\n                throw new FS.ErrnoError(8);\n            } if (FS.isDir(stream.node.mode)) {\n                throw new FS.ErrnoError(31);\n            } if (!stream.stream_ops.write) {\n                throw new FS.ErrnoError(28);\n            } if (stream.seekable && stream.flags & 1024) {\n                FS.llseek(stream, 0, 2);\n            } var seeking = typeof position != \"undefined\"; if (!seeking) {\n                position = stream.position;\n            }\n            else if (!stream.seekable) {\n                throw new FS.ErrnoError(70);\n            } var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn); if (!seeking)\n                stream.position += bytesWritten; return bytesWritten; }, allocate: function (stream, offset, length) { if (FS.isClosed(stream)) {\n                throw new FS.ErrnoError(8);\n            } if (offset < 0 || length <= 0) {\n                throw new FS.ErrnoError(28);\n            } if ((stream.flags & 2097155) === 0) {\n                throw new FS.ErrnoError(8);\n            } if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n                throw new FS.ErrnoError(43);\n            } if (!stream.stream_ops.allocate) {\n                throw new FS.ErrnoError(138);\n            } stream.stream_ops.allocate(stream, offset, length); }, mmap: function (stream, length, position, prot, flags) { if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n                throw new FS.ErrnoError(2);\n            } if ((stream.flags & 2097155) === 1) {\n                throw new FS.ErrnoError(2);\n            } if (!stream.stream_ops.mmap) {\n                throw new FS.ErrnoError(43);\n            } return stream.stream_ops.mmap(stream, length, position, prot, flags); }, msync: function (stream, buffer, offset, length, mmapFlags) { if (!stream.stream_ops.msync) {\n                return 0;\n            } return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags); }, munmap: function (stream) { return 0; }, ioctl: function (stream, cmd, arg) { if (!stream.stream_ops.ioctl) {\n                throw new FS.ErrnoError(59);\n            } return stream.stream_ops.ioctl(stream, cmd, arg); }, readFile: function (path, opts) {\n                if (opts === void 0) { opts = {}; }\n                opts.flags = opts.flags || 0;\n                opts.encoding = opts.encoding || \"binary\";\n                if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\n                    throw new Error(\"Invalid encoding type \\\"\".concat(opts.encoding, \"\\\"\"));\n                }\n                var ret;\n                var stream = FS.open(path, opts.flags);\n                var stat = FS.stat(path);\n                var length = stat.size;\n                var buf = new Uint8Array(length);\n                FS.read(stream, buf, 0, length, 0);\n                if (opts.encoding === \"utf8\") {\n                    ret = UTF8ArrayToString(buf, 0);\n                }\n                else if (opts.encoding === \"binary\") {\n                    ret = buf;\n                }\n                FS.close(stream);\n                return ret;\n            }, writeFile: function (path, data, opts) {\n                if (opts === void 0) { opts = {}; }\n                opts.flags = opts.flags || 577;\n                var stream = FS.open(path, opts.flags, opts.mode);\n                if (typeof data == \"string\") {\n                    var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n                    var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n                    FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n                }\n                else if (ArrayBuffer.isView(data)) {\n                    FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n                }\n                else {\n                    throw new Error(\"Unsupported data type\");\n                }\n                FS.close(stream);\n            }, cwd: function () { return FS.currentPath; }, chdir: function (path) { var lookup = FS.lookupPath(path, { follow: true }); if (lookup.node === null) {\n                throw new FS.ErrnoError(44);\n            } if (!FS.isDir(lookup.node.mode)) {\n                throw new FS.ErrnoError(54);\n            } var errCode = FS.nodePermissions(lookup.node, \"x\"); if (errCode) {\n                throw new FS.ErrnoError(errCode);\n            } FS.currentPath = lookup.path; }, createDefaultDirectories: function () { FS.mkdir(\"/tmp\"); FS.mkdir(\"/home\"); FS.mkdir(\"/home/web_user\"); }, createDefaultDevices: function () { FS.mkdir(\"/dev\"); FS.registerDevice(FS.makedev(1, 3), { read: function () { return 0; }, write: function (stream, buffer, offset, length, pos) { return length; } }); FS.mkdev(\"/dev/null\", FS.makedev(1, 3)); TTY.register(FS.makedev(5, 0), TTY.default_tty_ops); TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops); FS.mkdev(\"/dev/tty\", FS.makedev(5, 0)); FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0)); var randomBuffer = new Uint8Array(1024), randomLeft = 0; var randomByte = function () { if (randomLeft === 0) {\n                randomLeft = randomFill(randomBuffer).byteLength;\n            } return randomBuffer[--randomLeft]; }; FS.createDevice(\"/dev\", \"random\", randomByte); FS.createDevice(\"/dev\", \"urandom\", randomByte); FS.mkdir(\"/dev/shm\"); FS.mkdir(\"/dev/shm/tmp\"); }, createSpecialDirectories: function () { FS.mkdir(\"/proc\"); var proc_self = FS.mkdir(\"/proc/self\"); FS.mkdir(\"/proc/self/fd\"); FS.mount({ mount: function () { var node = FS.createNode(proc_self, \"fd\", 16384 | 511, 73); node.node_ops = { lookup: function (parent, name) { var fd = +name; var stream = FS.getStreamChecked(fd); var ret = { parent: null, mount: { mountpoint: \"fake\" }, node_ops: { readlink: function () { return stream.path; } } }; ret.parent = ret; return ret; } }; return node; } }, {}, \"/proc/self/fd\"); }, createStandardStreams: function () { if (Module[\"stdin\"]) {\n                FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n            }\n            else {\n                FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n            } if (Module[\"stdout\"]) {\n                FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n            }\n            else {\n                FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n            } if (Module[\"stderr\"]) {\n                FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n            }\n            else {\n                FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n            } var stdin = FS.open(\"/dev/stdin\", 0); var stdout = FS.open(\"/dev/stdout\", 1); var stderr = FS.open(\"/dev/stderr\", 1); }, ensureErrnoError: function () { if (FS.ErrnoError)\n                return; FS.ErrnoError = function ErrnoError(errno, node) { this.name = \"ErrnoError\"; this.node = node; this.setErrno = function (errno) { this.errno = errno; }; this.setErrno(errno); this.message = \"FS error\"; }; FS.ErrnoError.prototype = new Error; FS.ErrnoError.prototype.constructor = FS.ErrnoError; [44].forEach((function (code) { FS.genericErrors[code] = new FS.ErrnoError(code); FS.genericErrors[code].stack = \"<generic error, no stack>\"; })); }, staticInit: function () { FS.ensureErrnoError(); FS.nameTable = new Array(4096); FS.mount(MEMFS, {}, \"/\"); FS.createDefaultDirectories(); FS.createDefaultDevices(); FS.createSpecialDirectories(); FS.filesystems = { \"MEMFS\": MEMFS }; }, init: function (input, output, error) { FS.init.initialized = true; FS.ensureErrnoError(); Module[\"stdin\"] = input || Module[\"stdin\"]; Module[\"stdout\"] = output || Module[\"stdout\"]; Module[\"stderr\"] = error || Module[\"stderr\"]; FS.createStandardStreams(); }, quit: function () { FS.init.initialized = false; for (var i = 0; i < FS.streams.length; i++) {\n                var stream = FS.streams[i];\n                if (!stream) {\n                    continue;\n                }\n                FS.close(stream);\n            } }, findObject: function (path, dontResolveLastLink) { var ret = FS.analyzePath(path, dontResolveLastLink); if (!ret.exists) {\n                return null;\n            } return ret.object; }, analyzePath: function (path, dontResolveLastLink) { try {\n                var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n                path = lookup.path;\n            }\n            catch (e) { } var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null }; try {\n                var lookup = FS.lookupPath(path, { parent: true });\n                ret.parentExists = true;\n                ret.parentPath = lookup.path;\n                ret.parentObject = lookup.node;\n                ret.name = PATH.basename(path);\n                lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n                ret.exists = true;\n                ret.path = lookup.path;\n                ret.object = lookup.node;\n                ret.name = lookup.node.name;\n                ret.isRoot = lookup.path === \"/\";\n            }\n            catch (e) {\n                ret.error = e.errno;\n            } return ret; }, createPath: function (parent, path, canRead, canWrite) { parent = typeof parent == \"string\" ? parent : FS.getPath(parent); var parts = path.split(\"/\").reverse(); while (parts.length) {\n                var part = parts.pop();\n                if (!part)\n                    continue;\n                var current = PATH.join2(parent, part);\n                try {\n                    FS.mkdir(current);\n                }\n                catch (e) { }\n                parent = current;\n            } return current; }, createFile: function (parent, name, properties, canRead, canWrite) { var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name); var mode = FS_getMode(canRead, canWrite); return FS.create(path, mode); }, createDataFile: function (parent, name, data, canRead, canWrite, canOwn) { var path = name; if (parent) {\n                parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n                path = name ? PATH.join2(parent, name) : parent;\n            } var mode = FS_getMode(canRead, canWrite); var node = FS.create(path, mode); if (data) {\n                if (typeof data == \"string\") {\n                    var arr = new Array(data.length);\n                    for (var i = 0, len = data.length; i < len; ++i)\n                        arr[i] = data.charCodeAt(i);\n                    data = arr;\n                }\n                FS.chmod(node, mode | 146);\n                var stream = FS.open(node, 577);\n                FS.write(stream, data, 0, data.length, 0, canOwn);\n                FS.close(stream);\n                FS.chmod(node, mode);\n            } return node; }, createDevice: function (parent, name, input, output) { var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name); var mode = FS_getMode(!!input, !!output); if (!FS.createDevice.major)\n                FS.createDevice.major = 64; var dev = FS.makedev(FS.createDevice.major++, 0); FS.registerDevice(dev, { open: function (stream) { stream.seekable = false; }, close: function (stream) { if (output && output.buffer && output.buffer.length) {\n                    output(10);\n                } }, read: function (stream, buffer, offset, length, pos) { var bytesRead = 0; for (var i = 0; i < length; i++) {\n                    var result;\n                    try {\n                        result = input();\n                    }\n                    catch (e) {\n                        throw new FS.ErrnoError(29);\n                    }\n                    if (result === undefined && bytesRead === 0) {\n                        throw new FS.ErrnoError(6);\n                    }\n                    if (result === null || result === undefined)\n                        break;\n                    bytesRead++;\n                    buffer[offset + i] = result;\n                } if (bytesRead) {\n                    stream.node.timestamp = Date.now();\n                } return bytesRead; }, write: function (stream, buffer, offset, length, pos) { for (var i = 0; i < length; i++) {\n                    try {\n                        output(buffer[offset + i]);\n                    }\n                    catch (e) {\n                        throw new FS.ErrnoError(29);\n                    }\n                } if (length) {\n                    stream.node.timestamp = Date.now();\n                } return i; } }); return FS.mkdev(path, mode, dev); }, forceLoadFile: function (obj) { if (obj.isDevice || obj.isFolder || obj.link || obj.contents)\n                return true; if (typeof XMLHttpRequest != \"undefined\") {\n                throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n            }\n            else if (read_) {\n                try {\n                    obj.contents = intArrayFromString(read_(obj.url), true);\n                    obj.usedBytes = obj.contents.length;\n                }\n                catch (e) {\n                    throw new FS.ErrnoError(29);\n                }\n            }\n            else {\n                throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n            } }, createLazyFile: function (parent, name, url, canRead, canWrite) { function LazyUint8Array() { this.lengthKnown = false; this.chunks = []; } LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) { if (idx > this.length - 1 || idx < 0) {\n                return undefined;\n            } var chunkOffset = idx % this.chunkSize; var chunkNum = idx / this.chunkSize | 0; return this.getter(chunkNum)[chunkOffset]; }; LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) { this.getter = getter; }; LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() { var xhr = new XMLHttpRequest; xhr.open(\"HEAD\", url, false); xhr.send(null); if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))\n                throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status); var datalength = Number(xhr.getResponseHeader(\"Content-length\")); var header; var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\"; var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\"; var chunkSize = 1024 * 1024; if (!hasByteServing)\n                chunkSize = datalength; var doXHR = function (from, to) { if (from > to)\n                throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\"); if (to > datalength - 1)\n                throw new Error(\"only \" + datalength + \" bytes available! programmer error!\"); var xhr = new XMLHttpRequest; xhr.open(\"GET\", url, false); if (datalength !== chunkSize)\n                xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to); xhr.responseType = \"arraybuffer\"; if (xhr.overrideMimeType) {\n                xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n            } xhr.send(null); if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))\n                throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status); if (xhr.response !== undefined) {\n                return new Uint8Array(xhr.response || []);\n            } return intArrayFromString(xhr.responseText || \"\", true); }; var lazyArray = this; lazyArray.setDataGetter((function (chunkNum) { var start = chunkNum * chunkSize; var end = (chunkNum + 1) * chunkSize - 1; end = Math.min(end, datalength - 1); if (typeof lazyArray.chunks[chunkNum] == \"undefined\") {\n                lazyArray.chunks[chunkNum] = doXHR(start, end);\n            } if (typeof lazyArray.chunks[chunkNum] == \"undefined\")\n                throw new Error(\"doXHR failed!\"); return lazyArray.chunks[chunkNum]; })); if (usesGzip || !datalength) {\n                chunkSize = datalength = 1;\n                datalength = this.getter(0).length;\n                chunkSize = datalength;\n                out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n            } this._length = datalength; this._chunkSize = chunkSize; this.lengthKnown = true; }; if (typeof XMLHttpRequest != \"undefined\") {\n                if (!ENVIRONMENT_IS_WORKER)\n                    throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n                var lazyArray = new LazyUint8Array;\n                Object.defineProperties(lazyArray, { length: { get: function () { if (!this.lengthKnown) {\n                            this.cacheLength();\n                        } return this._length; } }, chunkSize: { get: function () { if (!this.lengthKnown) {\n                            this.cacheLength();\n                        } return this._chunkSize; } } });\n                var properties = { isDevice: false, contents: lazyArray };\n            }\n            else {\n                var properties = { isDevice: false, url: url };\n            } var node = FS.createFile(parent, name, properties, canRead, canWrite); if (properties.contents) {\n                node.contents = properties.contents;\n            }\n            else if (properties.url) {\n                node.contents = null;\n                node.url = properties.url;\n            } Object.defineProperties(node, { usedBytes: { get: function () { return this.contents.length; } } }); var stream_ops = {}; var keys = Object.keys(node.stream_ops); keys.forEach((function (key) { var fn = node.stream_ops[key]; stream_ops[key] = function forceLoadLazyFile() { FS.forceLoadFile(node); return fn.apply(null, arguments); }; })); function writeChunks(stream, buffer, offset, length, position) { var contents = stream.node.contents; if (position >= contents.length)\n                return 0; var size = Math.min(contents.length - position, length); if (contents.slice) {\n                for (var i = 0; i < size; i++) {\n                    buffer[offset + i] = contents[position + i];\n                }\n            }\n            else {\n                for (var i = 0; i < size; i++) {\n                    buffer[offset + i] = contents.get(position + i);\n                }\n            } return size; } stream_ops.read = function (stream, buffer, offset, length, position) { FS.forceLoadFile(node); return writeChunks(stream, buffer, offset, length, position); }; stream_ops.mmap = function (stream, length, position, prot, flags) { FS.forceLoadFile(node); var ptr = mmapAlloc(length); if (!ptr) {\n                throw new FS.ErrnoError(48);\n            } writeChunks(stream, HEAP8, ptr, length, position); return { ptr: ptr, allocated: true }; }; node.stream_ops = stream_ops; return node; } };\n        var UTF8ToString = function (ptr, maxBytesToRead) { return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\"; };\n        var SYSCALLS = { DEFAULT_POLLMASK: 5, calculateAt: function (dirfd, path, allowEmpty) { if (PATH.isAbs(path)) {\n                return path;\n            } var dir; if (dirfd === -100) {\n                dir = FS.cwd();\n            }\n            else {\n                var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n                dir = dirstream.path;\n            } if (path.length == 0) {\n                if (!allowEmpty) {\n                    throw new FS.ErrnoError(44);\n                }\n                return dir;\n            } return PATH.join2(dir, path); }, doStat: function (func, path, buf) { try {\n                var stat = func(path);\n            }\n            catch (e) {\n                if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n                    return -54;\n                }\n                throw e;\n            } HEAP32[buf >> 2] = stat.dev; HEAP32[buf + 4 >> 2] = stat.mode; HEAPU32[buf + 8 >> 2] = stat.nlink; HEAP32[buf + 12 >> 2] = stat.uid; HEAP32[buf + 16 >> 2] = stat.gid; HEAP32[buf + 20 >> 2] = stat.rdev; tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1]; HEAP32[buf + 32 >> 2] = 4096; HEAP32[buf + 36 >> 2] = stat.blocks; var atime = stat.atime.getTime(); var mtime = stat.mtime.getTime(); var ctime = stat.ctime.getTime(); tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1]; HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3; tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1]; HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3; tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1]; HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3; tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1]; return 0; }, doMsync: function (addr, stream, len, flags, offset) { if (!FS.isFile(stream.node.mode)) {\n                throw new FS.ErrnoError(43);\n            } if (flags & 2) {\n                return 0;\n            } var buffer = HEAPU8.slice(addr, addr + len); FS.msync(stream, buffer, offset, len, flags); }, varargs: undefined, get: function () { SYSCALLS.varargs += 4; var ret = HEAP32[SYSCALLS.varargs - 4 >> 2]; return ret; }, getStr: function (ptr) { var ret = UTF8ToString(ptr); return ret; }, getStreamFromFD: function (fd) { var stream = FS.getStreamChecked(fd); return stream; } };\n        function ___syscall_dup(fd) { try {\n            var old = SYSCALLS.getStreamFromFD(fd);\n            return FS.createStream(old).fd;\n        }\n        catch (e) {\n            if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\"))\n                throw e;\n            return -e.errno;\n        } }\n        var setErrNo = function (value) { HEAP32[___errno_location() >> 2] = value; return value; };\n        function ___syscall_fcntl64(fd, cmd, varargs) { SYSCALLS.varargs = varargs; try {\n            var stream = SYSCALLS.getStreamFromFD(fd);\n            switch (cmd) {\n                case 0: {\n                    var arg = SYSCALLS.get();\n                    if (arg < 0) {\n                        return -28;\n                    }\n                    var newStream;\n                    newStream = FS.createStream(stream, arg);\n                    return newStream.fd;\n                }\n                case 1:\n                case 2: return 0;\n                case 3: return stream.flags;\n                case 4: {\n                    var arg = SYSCALLS.get();\n                    stream.flags |= arg;\n                    return 0;\n                }\n                case 5: {\n                    var arg = SYSCALLS.get();\n                    var offset = 0;\n                    HEAP16[arg + offset >> 1] = 2;\n                    return 0;\n                }\n                case 6:\n                case 7: return 0;\n                case 16:\n                case 8: return -28;\n                case 9:\n                    setErrNo(28);\n                    return -1;\n                default: {\n                    return -28;\n                }\n            }\n        }\n        catch (e) {\n            if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\"))\n                throw e;\n            return -e.errno;\n        } }\n        function ___syscall_fstat64(fd, buf) { try {\n            var stream = SYSCALLS.getStreamFromFD(fd);\n            return SYSCALLS.doStat(FS.stat, stream.path, buf);\n        }\n        catch (e) {\n            if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\"))\n                throw e;\n            return -e.errno;\n        } }\n        function ___syscall_lstat64(path, buf) { try {\n            path = SYSCALLS.getStr(path);\n            return SYSCALLS.doStat(FS.lstat, path, buf);\n        }\n        catch (e) {\n            if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\"))\n                throw e;\n            return -e.errno;\n        } }\n        function ___syscall_newfstatat(dirfd, path, buf, flags) { try {\n            path = SYSCALLS.getStr(path);\n            var nofollow = flags & 256;\n            var allowEmpty = flags & 4096;\n            flags = flags & ~6400;\n            path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);\n            return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);\n        }\n        catch (e) {\n            if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\"))\n                throw e;\n            return -e.errno;\n        } }\n        function ___syscall_openat(dirfd, path, flags, varargs) { SYSCALLS.varargs = varargs; try {\n            path = SYSCALLS.getStr(path);\n            path = SYSCALLS.calculateAt(dirfd, path);\n            var mode = varargs ? SYSCALLS.get() : 0;\n            return FS.open(path, flags, mode).fd;\n        }\n        catch (e) {\n            if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\"))\n                throw e;\n            return -e.errno;\n        } }\n        var PIPEFS = { BUCKET_BUFFER_SIZE: 8192, mount: function (mount) { return FS.createNode(null, \"/\", 16384 | 511, 0); }, createPipe: function () { var pipe = { buckets: [], refcnt: 2 }; pipe.buckets.push({ buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE), offset: 0, roffset: 0 }); var rName = PIPEFS.nextname(); var wName = PIPEFS.nextname(); var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0); var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0); rNode.pipe = pipe; wNode.pipe = pipe; var readableStream = FS.createStream({ path: rName, node: rNode, flags: 0, seekable: false, stream_ops: PIPEFS.stream_ops }); rNode.stream = readableStream; var writableStream = FS.createStream({ path: wName, node: wNode, flags: 1, seekable: false, stream_ops: PIPEFS.stream_ops }); wNode.stream = writableStream; return { readable_fd: readableStream.fd, writable_fd: writableStream.fd }; }, stream_ops: { poll: function (stream) { var pipe = stream.node.pipe; if ((stream.flags & 2097155) === 1) {\n                    return 256 | 4;\n                } if (pipe.buckets.length > 0) {\n                    for (var i = 0; i < pipe.buckets.length; i++) {\n                        var bucket = pipe.buckets[i];\n                        if (bucket.offset - bucket.roffset > 0) {\n                            return 64 | 1;\n                        }\n                    }\n                } return 0; }, ioctl: function (stream, request, varargs) { return 28; }, fsync: function (stream) { return 28; }, read: function (stream, buffer, offset, length, position) { var pipe = stream.node.pipe; var currentLength = 0; for (var i = 0; i < pipe.buckets.length; i++) {\n                    var bucket = pipe.buckets[i];\n                    currentLength += bucket.offset - bucket.roffset;\n                } assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer)); var data = buffer.subarray(offset, offset + length); if (length <= 0) {\n                    return 0;\n                } if (currentLength == 0) {\n                    throw new FS.ErrnoError(6);\n                } var toRead = Math.min(currentLength, length); var totalRead = toRead; var toRemove = 0; for (var i = 0; i < pipe.buckets.length; i++) {\n                    var currBucket = pipe.buckets[i];\n                    var bucketSize = currBucket.offset - currBucket.roffset;\n                    if (toRead <= bucketSize) {\n                        var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);\n                        if (toRead < bucketSize) {\n                            tmpSlice = tmpSlice.subarray(0, toRead);\n                            currBucket.roffset += toRead;\n                        }\n                        else {\n                            toRemove++;\n                        }\n                        data.set(tmpSlice);\n                        break;\n                    }\n                    else {\n                        var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);\n                        data.set(tmpSlice);\n                        data = data.subarray(tmpSlice.byteLength);\n                        toRead -= tmpSlice.byteLength;\n                        toRemove++;\n                    }\n                } if (toRemove && toRemove == pipe.buckets.length) {\n                    toRemove--;\n                    pipe.buckets[toRemove].offset = 0;\n                    pipe.buckets[toRemove].roffset = 0;\n                } pipe.buckets.splice(0, toRemove); return totalRead; }, write: function (stream, buffer, offset, length, position) { var pipe = stream.node.pipe; assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer)); var data = buffer.subarray(offset, offset + length); var dataLen = data.byteLength; if (dataLen <= 0) {\n                    return 0;\n                } var currBucket = null; if (pipe.buckets.length == 0) {\n                    currBucket = { buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE), offset: 0, roffset: 0 };\n                    pipe.buckets.push(currBucket);\n                }\n                else {\n                    currBucket = pipe.buckets[pipe.buckets.length - 1];\n                } assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE); var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset; if (freeBytesInCurrBuffer >= dataLen) {\n                    currBucket.buffer.set(data, currBucket.offset);\n                    currBucket.offset += dataLen;\n                    return dataLen;\n                }\n                else if (freeBytesInCurrBuffer > 0) {\n                    currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);\n                    currBucket.offset += freeBytesInCurrBuffer;\n                    data = data.subarray(freeBytesInCurrBuffer, data.byteLength);\n                } var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0; var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE; for (var i = 0; i < numBuckets; i++) {\n                    var newBucket = { buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE), offset: PIPEFS.BUCKET_BUFFER_SIZE, roffset: 0 };\n                    pipe.buckets.push(newBucket);\n                    newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));\n                    data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);\n                } if (remElements > 0) {\n                    var newBucket = { buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE), offset: data.byteLength, roffset: 0 };\n                    pipe.buckets.push(newBucket);\n                    newBucket.buffer.set(data);\n                } return dataLen; }, close: function (stream) { var pipe = stream.node.pipe; pipe.refcnt--; if (pipe.refcnt === 0) {\n                    pipe.buckets = null;\n                } } }, nextname: function () { if (!PIPEFS.nextname.current) {\n                PIPEFS.nextname.current = 0;\n            } return \"pipe[\" + PIPEFS.nextname.current++ + \"]\"; } };\n        function ___syscall_pipe(fdPtr) { try {\n            if (fdPtr == 0) {\n                throw new FS.ErrnoError(21);\n            }\n            var res = PIPEFS.createPipe();\n            HEAP32[fdPtr >> 2] = res.readable_fd;\n            HEAP32[fdPtr + 4 >> 2] = res.writable_fd;\n            return 0;\n        }\n        catch (e) {\n            if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\"))\n                throw e;\n            return -e.errno;\n        } }\n        function ___syscall_poll(fds, nfds, timeout) { try {\n            var nonzero = 0;\n            for (var i = 0; i < nfds; i++) {\n                var pollfd = fds + 8 * i;\n                var fd = HEAP32[pollfd >> 2];\n                var events = HEAP16[pollfd + 4 >> 1];\n                var mask = 32;\n                var stream = FS.getStream(fd);\n                if (stream) {\n                    mask = SYSCALLS.DEFAULT_POLLMASK;\n                    if (stream.stream_ops.poll) {\n                        mask = stream.stream_ops.poll(stream, -1);\n                    }\n                }\n                mask &= events | 8 | 16;\n                if (mask)\n                    nonzero++;\n                HEAP16[pollfd + 6 >> 1] = mask;\n            }\n            return nonzero;\n        }\n        catch (e) {\n            if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\"))\n                throw e;\n            return -e.errno;\n        } }\n        function ___syscall_stat64(path, buf) { try {\n            path = SYSCALLS.getStr(path);\n            return SYSCALLS.doStat(FS.stat, path, buf);\n        }\n        catch (e) {\n            if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\"))\n                throw e;\n            return -e.errno;\n        } }\n        var isLeapYear = function (year) { return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0); };\n        var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];\n        var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n        var ydayFromDate = function (date) { var leap = isLeapYear(date.getFullYear()); var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE; var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1; return yday; };\n        function convertI32PairToI53Checked(lo, hi) { return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN; }\n        function __localtime_js(time_low, time_high, tmPtr) { var time = convertI32PairToI53Checked(time_low, time_high); var date = new Date(time * 1e3); HEAP32[tmPtr >> 2] = date.getSeconds(); HEAP32[tmPtr + 4 >> 2] = date.getMinutes(); HEAP32[tmPtr + 8 >> 2] = date.getHours(); HEAP32[tmPtr + 12 >> 2] = date.getDate(); HEAP32[tmPtr + 16 >> 2] = date.getMonth(); HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900; HEAP32[tmPtr + 24 >> 2] = date.getDay(); var yday = ydayFromDate(date) | 0; HEAP32[tmPtr + 28 >> 2] = yday; HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60); var start = new Date(date.getFullYear(), 0, 1); var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset(); var winterOffset = start.getTimezoneOffset(); var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0; HEAP32[tmPtr + 32 >> 2] = dst; }\n        var __mktime_js = function (tmPtr) { var ret = (function () { var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0); var dst = HEAP32[tmPtr + 32 >> 2]; var guessedOffset = date.getTimezoneOffset(); var start = new Date(date.getFullYear(), 0, 1); var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset(); var winterOffset = start.getTimezoneOffset(); var dstOffset = Math.min(winterOffset, summerOffset); if (dst < 0) {\n            HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);\n        }\n        else if (dst > 0 != (dstOffset == guessedOffset)) {\n            var nonDstOffset = Math.max(winterOffset, summerOffset);\n            var trueOffset = dst > 0 ? dstOffset : nonDstOffset;\n            date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);\n        } HEAP32[tmPtr + 24 >> 2] = date.getDay(); var yday = ydayFromDate(date) | 0; HEAP32[tmPtr + 28 >> 2] = yday; HEAP32[tmPtr >> 2] = date.getSeconds(); HEAP32[tmPtr + 4 >> 2] = date.getMinutes(); HEAP32[tmPtr + 8 >> 2] = date.getHours(); HEAP32[tmPtr + 12 >> 2] = date.getDate(); HEAP32[tmPtr + 16 >> 2] = date.getMonth(); HEAP32[tmPtr + 20 >> 2] = date.getYear(); return date.getTime() / 1e3; })(); return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0; };\n        var __timegm_js = function (tmPtr) { var ret = (function () { var time = Date.UTC(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0); var date = new Date(time); HEAP32[tmPtr + 24 >> 2] = date.getUTCDay(); var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0); var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0; HEAP32[tmPtr + 28 >> 2] = yday; return date.getTime() / 1e3; })(); return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0; };\n        var stringToUTF8 = function (str, outPtr, maxBytesToWrite) { return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite); };\n        var stringToNewUTF8 = function (str) { var size = lengthBytesUTF8(str) + 1; var ret = _malloc(size); if (ret)\n            stringToUTF8(str, ret, size); return ret; };\n        var __tzset_js = function (timezone, daylight, tzname) { var currentYear = (new Date).getFullYear(); var winter = new Date(currentYear, 0, 1); var summer = new Date(currentYear, 6, 1); var winterOffset = winter.getTimezoneOffset(); var summerOffset = summer.getTimezoneOffset(); var stdTimezoneOffset = Math.max(winterOffset, summerOffset); HEAPU32[timezone >> 2] = stdTimezoneOffset * 60; HEAP32[daylight >> 2] = Number(winterOffset != summerOffset); function extractZone(date) { var match = date.toTimeString().match(/\\(([A-Za-z ]+)\\)$/); return match ? match[1] : \"GMT\"; } var winterName = extractZone(winter); var summerName = extractZone(summer); var winterNamePtr = stringToNewUTF8(winterName); var summerNamePtr = stringToNewUTF8(summerName); if (summerOffset < winterOffset) {\n            HEAPU32[tzname >> 2] = winterNamePtr;\n            HEAPU32[tzname + 4 >> 2] = summerNamePtr;\n        }\n        else {\n            HEAPU32[tzname >> 2] = summerNamePtr;\n            HEAPU32[tzname + 4 >> 2] = winterNamePtr;\n        } };\n        var _abort = function () { abort(\"\"); };\n        var _emscripten_memcpy_big = function (dest, src, num) { return HEAPU8.copyWithin(dest, src, src + num); };\n        var getHeapMax = function () { return 2147483648; };\n        var growMemory = function (size) { var b = wasmMemory.buffer; var pages = size - b.byteLength + 65535 >>> 16; try {\n            wasmMemory.grow(pages);\n            updateMemoryViews();\n            return 1;\n        }\n        catch (e) { } };\n        var _emscripten_resize_heap = function (requestedSize) { var oldSize = HEAPU8.length; requestedSize >>>= 0; var maxHeapSize = getHeapMax(); if (requestedSize > maxHeapSize) {\n            return false;\n        } var alignUp = function (x, multiple) { return x + (multiple - x % multiple) % multiple; }; for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n            var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n            var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n            var replacement = growMemory(newSize);\n            if (replacement) {\n                return true;\n            }\n        } return false; };\n        var ENV = {};\n        var getExecutableName = function () { return thisProgram || \"./this.program\"; };\n        var getEnvStrings = function () { if (!getEnvStrings.strings) {\n            var lang = (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\n            var env = { \"USER\": \"web_user\", \"LOGNAME\": \"web_user\", \"PATH\": \"/\", \"PWD\": \"/\", \"HOME\": \"/home/web_user\", \"LANG\": lang, \"_\": getExecutableName() };\n            for (var x in ENV) {\n                if (ENV[x] === undefined)\n                    delete env[x];\n                else\n                    env[x] = ENV[x];\n            }\n            var strings = [];\n            for (var x in env) {\n                strings.push(\"\".concat(x, \"=\").concat(env[x]));\n            }\n            getEnvStrings.strings = strings;\n        } return getEnvStrings.strings; };\n        var stringToAscii = function (str, buffer) { for (var i = 0; i < str.length; ++i) {\n            HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n        } HEAP8[buffer >> 0] = 0; };\n        var _environ_get = function (__environ, environ_buf) { var bufSize = 0; getEnvStrings().forEach((function (string, i) { var ptr = environ_buf + bufSize; HEAPU32[__environ + i * 4 >> 2] = ptr; stringToAscii(string, ptr); bufSize += string.length + 1; })); return 0; };\n        var _environ_sizes_get = function (penviron_count, penviron_buf_size) { var strings = getEnvStrings(); HEAPU32[penviron_count >> 2] = strings.length; var bufSize = 0; strings.forEach((function (string) { bufSize += string.length + 1; })); HEAPU32[penviron_buf_size >> 2] = bufSize; return 0; };\n        var _proc_exit = function (code) { EXITSTATUS = code; if (!keepRuntimeAlive()) {\n            if (Module[\"onExit\"])\n                Module[\"onExit\"](code);\n            ABORT = true;\n        } quit_(code, new ExitStatus(code)); };\n        var exitJS = function (status, implicit) { EXITSTATUS = status; _proc_exit(status); };\n        var _exit = exitJS;\n        function _fd_close(fd) { try {\n            var stream = SYSCALLS.getStreamFromFD(fd);\n            FS.close(stream);\n            return 0;\n        }\n        catch (e) {\n            if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\"))\n                throw e;\n            return e.errno;\n        } }\n        var doReadv = function (stream, iov, iovcnt, offset) { var ret = 0; for (var i = 0; i < iovcnt; i++) {\n            var ptr = HEAPU32[iov >> 2];\n            var len = HEAPU32[iov + 4 >> 2];\n            iov += 8;\n            var curr = FS.read(stream, HEAP8, ptr, len, offset);\n            if (curr < 0)\n                return -1;\n            ret += curr;\n            if (curr < len)\n                break;\n            if (typeof offset !== \"undefined\") {\n                offset += curr;\n            }\n        } return ret; };\n        function _fd_read(fd, iov, iovcnt, pnum) { try {\n            var stream = SYSCALLS.getStreamFromFD(fd);\n            var num = doReadv(stream, iov, iovcnt);\n            HEAPU32[pnum >> 2] = num;\n            return 0;\n        }\n        catch (e) {\n            if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\"))\n                throw e;\n            return e.errno;\n        } }\n        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) { var offset = convertI32PairToI53Checked(offset_low, offset_high); try {\n            if (isNaN(offset))\n                return 61;\n            var stream = SYSCALLS.getStreamFromFD(fd);\n            FS.llseek(stream, offset, whence);\n            tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\n            if (stream.getdents && offset === 0 && whence === 0)\n                stream.getdents = null;\n            return 0;\n        }\n        catch (e) {\n            if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\"))\n                throw e;\n            return e.errno;\n        } }\n        var doWritev = function (stream, iov, iovcnt, offset) { var ret = 0; for (var i = 0; i < iovcnt; i++) {\n            var ptr = HEAPU32[iov >> 2];\n            var len = HEAPU32[iov + 4 >> 2];\n            iov += 8;\n            var curr = FS.write(stream, HEAP8, ptr, len, offset);\n            if (curr < 0)\n                return -1;\n            ret += curr;\n            if (typeof offset !== \"undefined\") {\n                offset += curr;\n            }\n        } return ret; };\n        function _fd_write(fd, iov, iovcnt, pnum) { try {\n            var stream = SYSCALLS.getStreamFromFD(fd);\n            var num = doWritev(stream, iov, iovcnt);\n            HEAPU32[pnum >> 2] = num;\n            return 0;\n        }\n        catch (e) {\n            if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\"))\n                throw e;\n            return e.errno;\n        } }\n        function getCFunc(ident) { var func = Module[\"_\" + ident]; return func; }\n        var writeArrayToMemory = function (array, buffer) { HEAP8.set(array, buffer); };\n        var stringToUTF8OnStack = function (str) { var size = lengthBytesUTF8(str) + 1; var ret = stackAlloc(size); stringToUTF8(str, ret, size); return ret; };\n        var ccall = function (ident, returnType, argTypes, args, opts) { var toC = { \"string\": function (str) { var ret = 0; if (str !== null && str !== undefined && str !== 0) {\n                ret = stringToUTF8OnStack(str);\n            } return ret; }, \"array\": function (arr) { var ret = stackAlloc(arr.length); writeArrayToMemory(arr, ret); return ret; } }; function convertReturnValue(ret) { if (returnType === \"string\") {\n            return UTF8ToString(ret);\n        } if (returnType === \"boolean\")\n            return Boolean(ret); return ret; } var func = getCFunc(ident); var cArgs = []; var stack = 0; if (args) {\n            for (var i = 0; i < args.length; i++) {\n                var converter = toC[argTypes[i]];\n                if (converter) {\n                    if (stack === 0)\n                        stack = stackSave();\n                    cArgs[i] = converter(args[i]);\n                }\n                else {\n                    cArgs[i] = args[i];\n                }\n            }\n        } var ret = func.apply(null, cArgs); function onDone(ret) { if (stack !== 0)\n            stackRestore(stack); return convertReturnValue(ret); } ret = onDone(ret); return ret; };\n        var cwrap = function (ident, returnType, argTypes, opts) { var numericArgs = !argTypes || argTypes.every((function (type) { return type === \"number\" || type === \"boolean\"; })); var numericRet = returnType !== \"string\"; if (numericRet && numericArgs && !opts) {\n            return getCFunc(ident);\n        } return function () { return ccall(ident, returnType, argTypes, arguments, opts); }; };\n        var FSNode = function (parent, name, mode, rdev) { if (!parent) {\n            parent = this;\n        } this.parent = parent; this.mount = parent.mount; this.mounted = null; this.id = FS.nextInode++; this.name = name; this.mode = mode; this.node_ops = {}; this.stream_ops = {}; this.rdev = rdev; };\n        var readMode = 292 | 73;\n        var writeMode = 146;\n        Object.defineProperties(FSNode.prototype, { read: { get: function () { return (this.mode & readMode) === readMode; }, set: function (val) { val ? this.mode |= readMode : this.mode &= ~readMode; } }, write: { get: function () { return (this.mode & writeMode) === writeMode; }, set: function (val) { val ? this.mode |= writeMode : this.mode &= ~writeMode; } }, isFolder: { get: function () { return FS.isDir(this.mode); } }, isDevice: { get: function () { return FS.isChrdev(this.mode); } } });\n        FS.FSNode = FSNode;\n        FS.createPreloadedFile = FS_createPreloadedFile;\n        FS.staticInit();\n        var wasmImports = { i: ___syscall_dup, a: ___syscall_fcntl64, v: ___syscall_fstat64, s: ___syscall_lstat64, t: ___syscall_newfstatat, w: ___syscall_openat, r: ___syscall_pipe, q: ___syscall_poll, u: ___syscall_stat64, k: __localtime_js, l: __mktime_js, m: __timegm_js, p: __tzset_js, d: _abort, h: _emscripten_memcpy_big, o: _emscripten_resize_heap, f: _environ_get, g: _environ_sizes_get, e: _exit, c: _fd_close, j: _fd_read, n: _fd_seek, b: _fd_write };\n        var asm = createWasm();\n        var ___wasm_call_ctors = function () { return (___wasm_call_ctors = Module[\"asm\"][\"y\"]).apply(null, arguments); };\n        var _archive_read_new_memory = Module[\"_archive_read_new_memory\"] = function () { return (_archive_read_new_memory = Module[\"_archive_read_new_memory\"] = Module[\"asm\"][\"z\"]).apply(null, arguments); };\n        var _archive_read_new = Module[\"_archive_read_new\"] = function () { return (_archive_read_new = Module[\"_archive_read_new\"] = Module[\"asm\"][\"A\"]).apply(null, arguments); };\n        var _archive_read_support_filter_all = Module[\"_archive_read_support_filter_all\"] = function () { return (_archive_read_support_filter_all = Module[\"_archive_read_support_filter_all\"] = Module[\"asm\"][\"B\"]).apply(null, arguments); };\n        var _archive_read_support_format_all = Module[\"_archive_read_support_format_all\"] = function () { return (_archive_read_support_format_all = Module[\"_archive_read_support_format_all\"] = Module[\"asm\"][\"C\"]).apply(null, arguments); };\n        var _archive_read_add_passphrase = Module[\"_archive_read_add_passphrase\"] = function () { return (_archive_read_add_passphrase = Module[\"_archive_read_add_passphrase\"] = Module[\"asm\"][\"D\"]).apply(null, arguments); };\n        var _archive_read_open_memory = Module[\"_archive_read_open_memory\"] = function () { return (_archive_read_open_memory = Module[\"_archive_read_open_memory\"] = Module[\"asm\"][\"E\"]).apply(null, arguments); };\n        var _archive_read_next_entry = Module[\"_archive_read_next_entry\"] = function () { return (_archive_read_next_entry = Module[\"_archive_read_next_entry\"] = Module[\"asm\"][\"F\"]).apply(null, arguments); };\n        var _archive_entry_ctime = Module[\"_archive_entry_ctime\"] = function () { return (_archive_entry_ctime = Module[\"_archive_entry_ctime\"] = Module[\"asm\"][\"H\"]).apply(null, arguments); };\n        var _archive_entry_filetype = Module[\"_archive_entry_filetype\"] = function () { return (_archive_entry_filetype = Module[\"_archive_entry_filetype\"] = Module[\"asm\"][\"I\"]).apply(null, arguments); };\n        var _archive_entry_hardlink_utf8 = Module[\"_archive_entry_hardlink_utf8\"] = function () { return (_archive_entry_hardlink_utf8 = Module[\"_archive_entry_hardlink_utf8\"] = Module[\"asm\"][\"J\"]).apply(null, arguments); };\n        var _archive_entry_mtime = Module[\"_archive_entry_mtime\"] = function () { return (_archive_entry_mtime = Module[\"_archive_entry_mtime\"] = Module[\"asm\"][\"K\"]).apply(null, arguments); };\n        var _archive_entry_pathname_utf8 = Module[\"_archive_entry_pathname_utf8\"] = function () { return (_archive_entry_pathname_utf8 = Module[\"_archive_entry_pathname_utf8\"] = Module[\"asm\"][\"L\"]).apply(null, arguments); };\n        var _archive_entry_size = Module[\"_archive_entry_size\"] = function () { return (_archive_entry_size = Module[\"_archive_entry_size\"] = Module[\"asm\"][\"M\"]).apply(null, arguments); };\n        var _archive_entry_symlink_utf8 = Module[\"_archive_entry_symlink_utf8\"] = function () { return (_archive_entry_symlink_utf8 = Module[\"_archive_entry_symlink_utf8\"] = Module[\"asm\"][\"N\"]).apply(null, arguments); };\n        var _archive_entry_is_encrypted = Module[\"_archive_entry_is_encrypted\"] = function () { return (_archive_entry_is_encrypted = Module[\"_archive_entry_is_encrypted\"] = Module[\"asm\"][\"O\"]).apply(null, arguments); };\n        var _free = Module[\"_free\"] = function () { return (_free = Module[\"_free\"] = Module[\"asm\"][\"P\"]).apply(null, arguments); };\n        var ___errno_location = function () { return (___errno_location = Module[\"asm\"][\"Q\"]).apply(null, arguments); };\n        var _malloc = Module[\"_malloc\"] = function () { return (_malloc = Module[\"_malloc\"] = Module[\"asm\"][\"R\"]).apply(null, arguments); };\n        var _archive_read_has_encrypted_entries = Module[\"_archive_read_has_encrypted_entries\"] = function () { return (_archive_read_has_encrypted_entries = Module[\"_archive_read_has_encrypted_entries\"] = Module[\"asm\"][\"S\"]).apply(null, arguments); };\n        var _archive_read_data = Module[\"_archive_read_data\"] = function () { return (_archive_read_data = Module[\"_archive_read_data\"] = Module[\"asm\"][\"T\"]).apply(null, arguments); };\n        var _archive_read_data_skip = Module[\"_archive_read_data_skip\"] = function () { return (_archive_read_data_skip = Module[\"_archive_read_data_skip\"] = Module[\"asm\"][\"U\"]).apply(null, arguments); };\n        var _archive_version_number = Module[\"_archive_version_number\"] = function () { return (_archive_version_number = Module[\"_archive_version_number\"] = Module[\"asm\"][\"V\"]).apply(null, arguments); };\n        var _archive_version_string = Module[\"_archive_version_string\"] = function () { return (_archive_version_string = Module[\"_archive_version_string\"] = Module[\"asm\"][\"W\"]).apply(null, arguments); };\n        var _archive_error_string = Module[\"_archive_error_string\"] = function () { return (_archive_error_string = Module[\"_archive_error_string\"] = Module[\"asm\"][\"X\"]).apply(null, arguments); };\n        var _archive_version_details = Module[\"_archive_version_details\"] = function () { return (_archive_version_details = Module[\"_archive_version_details\"] = Module[\"asm\"][\"Y\"]).apply(null, arguments); };\n        var _archive_read_free = Module[\"_archive_read_free\"] = function () { return (_archive_read_free = Module[\"_archive_read_free\"] = Module[\"asm\"][\"Z\"]).apply(null, arguments); };\n        var setTempRet0 = function () { return (setTempRet0 = Module[\"asm\"][\"_\"]).apply(null, arguments); };\n        var stackSave = function () { return (stackSave = Module[\"asm\"][\"$\"]).apply(null, arguments); };\n        var stackRestore = function () { return (stackRestore = Module[\"asm\"][\"aa\"]).apply(null, arguments); };\n        var stackAlloc = function () { return (stackAlloc = Module[\"asm\"][\"ba\"]).apply(null, arguments); };\n        Module[\"cwrap\"] = cwrap;\n        var calledRun;\n        dependenciesFulfilled = function runCaller() { if (!calledRun)\n            run(); if (!calledRun)\n            dependenciesFulfilled = runCaller; };\n        function run() { if (runDependencies > 0) {\n            return;\n        } preRun(); if (runDependencies > 0) {\n            return;\n        } function doRun() { if (calledRun)\n            return; calledRun = true; Module[\"calledRun\"] = true; if (ABORT)\n            return; initRuntime(); readyPromiseResolve(Module); if (Module[\"onRuntimeInitialized\"])\n            Module[\"onRuntimeInitialized\"](); postRun(); } if (Module[\"setStatus\"]) {\n            Module[\"setStatus\"](\"Running...\");\n            setTimeout((function () { setTimeout((function () { Module[\"setStatus\"](\"\"); }), 1); doRun(); }), 1);\n        }\n        else {\n            doRun();\n        } }\n        if (Module[\"preInit\"]) {\n            if (typeof Module[\"preInit\"] == \"function\")\n                Module[\"preInit\"] = [Module[\"preInit\"]];\n            while (Module[\"preInit\"].length > 0) {\n                Module[\"preInit\"].pop()();\n            }\n        }\n        run();\n        return moduleArg.ready;\n    });\n})();\nif (typeof exports === 'object' && typeof module === 'object')\n    module.exports = libarchive;\nelse if (typeof define === 'function' && define['amd'])\n    define([], function () { return libarchive; });\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.libarchiveWasm = void 0;\nvar libarchive_1 = __importDefault(require(\"./libarchive\"));\nvar wrapLibarchiveWasm_1 = require(\"./wrapLibarchiveWasm\");\nfunction libarchiveWasm() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return new Promise(function (resolve) {\n        libarchive_1.default.apply(void 0, args).then(function (mod) {\n            resolve((0, wrapLibarchiveWasm_1.wrapLibarchiveWasm)(mod));\n        });\n    });\n}\nexports.libarchiveWasm = libarchiveWasm;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.wrapLibarchiveWasm = void 0;\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nfunction wrapLibarchiveWasm(module) {\n    /* eslint-disable @typescript-eslint/no-explicit-any */\n    var checkReturnValue = function (fn, test) {\n        return function f() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var r = fn.apply(void 0, args);\n            if (test(r))\n                throw new Error(this.error_string(args[0]));\n            return r;\n        };\n    };\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n    var nonzero = function (r) { return r !== 0; };\n    return {\n        module: module,\n        version_number: module.cwrap('archive_version_number', 'number', []),\n        version_string: module.cwrap('archive_version_string', 'string', []),\n        version_details: module.cwrap('archive_version_details', 'string', []),\n        read_new_memory: checkReturnValue(module.cwrap('archive_read_new_memory', 'number', [\n            'number',\n            'number',\n            'string',\n        ]), function (r) { return r === 0; }),\n        read_new: module.cwrap('archive_read_new', 'number', []),\n        read_support_filter_all: checkReturnValue(module.cwrap('archive_read_support_filter_all', 'number', ['number']), nonzero),\n        read_support_format_all: checkReturnValue(module.cwrap('archive_read_support_format_all', 'number', ['number']), nonzero),\n        read_open_memory: checkReturnValue(module.cwrap('archive_read_open_memory', 'number', ['number', 'number', 'number']), nonzero),\n        read_next_entry: module.cwrap('archive_read_next_entry', 'number', ['number']),\n        read_has_encrypted_entries: module.cwrap('archive_read_has_encrypted_entries', 'number', [\n            'number',\n        ]),\n        read_data: checkReturnValue(module.cwrap('archive_read_data', 'number', ['number', 'number', 'number']), function (r) { return r < 0; }),\n        read_data_skip: checkReturnValue(module.cwrap('archive_read_data_skip', 'number', ['number']), nonzero),\n        read_add_passphrase: checkReturnValue(module.cwrap('archive_read_add_passphrase', 'number', ['number', 'string']), nonzero),\n        read_free: checkReturnValue(module.cwrap('archive_read_free', 'number', ['number']), nonzero),\n        error_string: module.cwrap('archive_error_string', 'string', ['number']),\n        entry_filetype: module.cwrap('archive_entry_filetype', 'number', ['number']),\n        entry_pathname: module.cwrap('archive_entry_pathname_utf8', 'string', ['number']),\n        entry_symlink: module.cwrap('archive_entry_symlink_utf8', 'string', ['number']),\n        entry_hardlink: module.cwrap('archive_entry_hardlink_utf8', 'string', ['number']),\n        entry_size: module.cwrap('archive_entry_size', 'number', ['number']),\n        entry_ctime: module.cwrap('archive_entry_ctime', 'number', ['number']),\n        entry_mtime: module.cwrap('archive_entry_mtime', 'number', ['number']),\n        entry_is_encrypted: module.cwrap('archive_entry_is_encrypted', 'number', ['number']),\n    };\n}\nexports.wrapLibarchiveWasm = wrapLibarchiveWasm;\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","import * as core from '@actions/core'\nimport * as fs from 'fs'\nimport { Readable } from 'stream'\nimport { finished } from 'stream/promises'\nimport { ReadableStream } from 'stream/web'\nimport path from 'path'\nimport os from 'os'\nimport util from 'util'\nimport { readFile, writeFile, mkdir, symlink } from 'node:fs/promises'\nimport { ArchiveReader, libarchiveWasm } from 'libarchive-wasm'\n\nconst PlatformMap = {\n  darwin: 'mac',\n  freebsd: 'linux',\n  linux: 'linux',\n  openbsd: 'linux',\n  win32: 'windows'\n}\n\nconst tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'qt-creator-downloader'))\n\n// Download the url and save it to the specified file\nasync function downloadPackage(\n  url: string,\n  destination: string\n): Promise<void> {\n  const res = await fetch(url)\n  if (!res.body) throw new Error('Response body is undefined')\n  if (res.status !== 200) {\n    throw new Error(`Failed to download ${url}: ${res.statusText}`)\n  }\n  const fileStream = fs.createWriteStream(destination, { flags: 'wx' })\n  return finished(Readable.fromWeb(res.body as ReadableStream).pipe(fileStream))\n}\n\nasync function downloadQtC(urls: string[]): Promise<string[]> {\n  const errors: string[] = []\n  const packages = ['qtcreator.7z', 'qtcreator_dev.7z']\n  for (const url of urls) {\n    try {\n      for (const packageName of packages) {\n        const fullUrl = `${url}/${packageName}`\n        core.info(`Downloading ${fullUrl}`)\n        await downloadPackage(fullUrl, `${tmpDir}/${packageName}`)\n      }\n      return packages.map(packageName => `${tmpDir}/${packageName}`)\n    } catch (error) {\n      core.warning(util.inspect(error))\n      errors.push(util.inspect(error))\n    }\n  }\n  throw new Error(\n    `Failed to download Qt Creator packages: ${errors.join('\\n')}`\n  )\n}\n\nasync function extract(archive: string, destination: string): Promise<void> {\n  console.log('Extracting', archive, 'to', destination)\n  const data = await readFile(archive)\n  const mod = await libarchiveWasm()\n  const reader = new ArchiveReader(mod, new Int8Array(data))\n  for (const entry of reader.entries()) {\n    const type = entry.getFiletype()\n    const pathName = entry.getPathname()\n    const destinationPath = path.join(destination, pathName)\n\n    if (path.isAbsolute(pathName)) {\n      throw new Error('Absolute path in archive detected, aborting.')\n    }\n\n    if (type === 'Directory') {\n      if (!fs.existsSync(destinationPath)) {\n        await mkdir(destinationPath)\n      } else if (!fs.statSync(destinationPath).isDirectory()) {\n        throw new Error(\n          `Path already exists and is not a directory: ${destinationPath}`\n        )\n      }\n      continue\n    } else if (type === 'SymbolicLink') {\n      await symlink(entry.getSymlinkTarget(), destinationPath)\n      continue\n    } else if (type === 'File') {\n      const size = entry.getSize()\n      if (size > 0) {\n        const entryData = entry.readData()\n        if (!entryData) throw new Error(`Failed to read data for ${pathName}`)\n        await writeFile(destinationPath, entryData)\n      } else {\n        await writeFile(destinationPath, '')\n      }\n    } else {\n      throw new Error(`Unsupported entry type: ${type}`)\n    }\n  }\n  reader.free()\n}\n\n/**\n * The main function for the action.\n * @returns {Promise<void>} Resolves when the action is complete.\n */\nexport async function run(): Promise<void> {\n  try {\n    const version: string = core.getInput('version')\n    const destination: string = core.getInput('unzip-to')\n    const platformInput: string = core.getInput('platform')\n\n    if (!platformInput && !(process.platform in PlatformMap)) {\n      core.setFailed(`Unsupported platform: ${process.platform}`)\n      return\n    }\n\n    const platformName: string =\n      PlatformMap[process.platform as keyof typeof PlatformMap]\n    const arch = process.platform === 'darwin' ? 'x64' : process.arch\n\n    const platform = platformInput ? platformInput : `${platformName}_${arch}`\n\n    // Extract the major and minor versions\n    const [major, minor] = version.split('.').slice(0, 2)\n    const folderPath = `${major}.${minor}/${version}`\n\n    const urls = [\n      `https://download.qt.io/official_releases/qtcreator/${folderPath}/installer_source/${platform}`,\n      `https://download.qt.io/development_releases/qtcreator/${folderPath}/installer_source/${platform}`,\n      `https://download.qt.io/snapshots/qtcreator/${folderPath}/installer_source/latest/${platform}`\n    ]\n\n    const packages = await downloadQtC(urls)\n\n    if (!fs.existsSync(destination)) {\n      fs.mkdirSync(destination, { recursive: true })\n    }\n\n    for (const packageFile of packages) {\n      // Unzip the downloaded file\n      core.info(`Unzipping package: ${packageFile}`)\n      await extract(packageFile, destination)\n    }\n\n    core.info(`Qt Creator ${version} has been extracted to ${destination}`)\n\n    // Set outputs for other workflow steps to use\n    core.setOutput('path', destination)\n    core.setOutput(\n      'path-with-slashes',\n      path.resolve(destination).split(path.sep).join('/')\n    )\n  } catch (error) {\n    // Fail the workflow run if an error occurs\n    core.setFailed(util.inspect(error))\n  }\n}\n","module.exports = require(\"assert\");","module.exports = require(\"child_process\");","module.exports = require(\"crypto\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"node:fs/promises\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"stream\");","module.exports = require(\"stream/promises\");","module.exports = require(\"string_decoder\");","module.exports = require(\"timers\");","module.exports = require(\"tls\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","/**\n * The entrypoint for the action.\n */\nimport { run } from './main'\n\nrun()\n"],"names":[],"sourceRoot":""}